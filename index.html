<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="纸上得来终觉浅，绝知此事要躬行。">
<meta property="og:type" content="website">
<meta property="og:title" content="olaf&#39;s site">
<meta property="og:url" content="https://olafcheng.github.io/index.html">
<meta property="og:site_name" content="olaf&#39;s site">
<meta property="og:description" content="纸上得来终觉浅，绝知此事要躬行。">
<meta property="og:locale" content="zh-cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="olaf&#39;s site">
<meta name="twitter:description" content="纸上得来终觉浅，绝知此事要躬行。">






  <link rel="canonical" href="https://olafcheng.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>olaf's site</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">olaf's site</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Home</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archives</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2018/11/18/music-tool/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/18/music-tool/" itemprop="url">
                  音名小工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-11-18 16:51:21 / Modified: 17:08:32" itemprop="dateCreated datePublished" datetime="2018-11-18T16:51:21+08:00">2018-11-18</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="音名小工具"><a href="#音名小工具" class="headerlink" title="音名小工具"></a>音名小工具</h1><p>因为最近在学电吉他，需要用随机的音名来检查自己对指板的掌握程度，所以写了个小工具用来给自己提音名。</p>
<p>点<a href="/demos/EADGBE/index.html">这里</a>打开小工具的页面。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2018/09/23/CURL-系列-8-3-——-HTTP-认证/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/23/CURL-系列-8-3-——-HTTP-认证/" itemprop="url">
                  CURL 系列(8.3) —— HTTP 认证
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-09-23 19:23:20 / Modified: 19:27:29" itemprop="dateCreated datePublished" datetime="2018-09-23T19:23:20+08:00">2018-09-23</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="CURL-系列-8-3-——-HTTP-认证"><a href="#CURL-系列-8-3-——-HTTP-认证" class="headerlink" title="CURL 系列(8.3) —— HTTP 认证"></a>CURL 系列(8.3) —— HTTP 认证</h1><p>原文: <a href="https://ec.haxx.se/http-auth.html" target="_blank" rel="noopener">Authentication · Everything curl - HTTP authentication</a></p>
<p>每个 HTTP 请求, 都可以被认证. 如果一个服务器或者一个代理想要让用户证明自己有权限去访问某个 URL 或者执行某个操作, 它可以返回一个 HTTP 请求, 让客户端提供一个包含了正确的 HTTP 认证头的请求, 以便认证和允许访问.</p>
<p>如果一个服务器需要认证才能进行访问的话, 会返回 401 码, 以及一个 <code>WWW-Authenticate:</code> 头, 这个头里包含了服务器支持的所有类型的认证方式.</p>
<p>如果一个 HTTP 代理需要认证的话, 会返回 407 码, 以及一个 <code>Proxy-Authenticate:</code> 头, 这个头里包含了代理支持的所有类型的认证方式.</p>
<p>值得一提的是, 当今的绝大多数网站已经不再需要 HTTP 认证来进行登录等等操作了, 但是取而代之的是, 网站会要求用户在网站的登录页上进行登录, 然后网站会把用户输入的用户名和密码以 POST 请求的方式发送给服务器, 随后客户端只需要维护着 cookie 来维护 session 即可.</p>
<p>为了让 curl 命令发起一个带有 HTTP 认证的请求, 你需要加上 <code>-u</code>  或者 <code>--user</code> 参数来提供用户名和密码(以冒号分隔). 就像下面这样:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --user daniel:secret http://example.com/</span><br></pre></td></tr></table></figure>
<p>这样一来， curl 就会以 HTTP 认证中的 “Basic” 方式发起一个认证请求. Basic 方法就像它的名字一样, 真的是一种非常基础的认证. 如果你想非常明确的发出一个 Basic 方法的认证的话, 只需要加上 <code>--basic</code> 参数就可以了.</p>
<p>Basic 认证方法直接以文本的格式通过网络来发送用户名和密码了（不过是用 base64 编码过了）, 然而这种 HTTP 明文发送用户名和密码的方式, 是应该避免的.</p>
<p>如果一定要通过 HTTP 传输、单认证方法的方式来进行认证的话, curl 会在第一个 HTTP 请求的头部里加上认证信息.</p>
<p>如果你想让 curl <em>试一下</em> 服务器是否需要认证, 可以给 curl 加上一个 <code>--anyauth</code> 参数. 这样一来, curl 就会先发送一个请求, 看看是否需要认证, 如果需要认证, 再自动地选择服务器所支持的最为安全的方式进行认证:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl --anyauth --user daniel:secret http://example.com/</span><br></pre></td></tr></table></figure></p>
<p>这样的思路在其他类型的可能会需要认证的 HTTP 操作上, 也行得通:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl --proxy-anyauth --proxy-user daniel:secret http://example.com/ \</span><br><span class="line">     --proxy http://proxy.example.com:80/</span><br></pre></td></tr></table></figure></p>
<p>curl 一般来说会同时支持好几种认证方式(取决于你在用的 curl 是如何实现的), 包括 Digest, Negotiate 和 NTLM. 如果你想用这些方式的话, 可以像这样加上参数来使用:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl --digest --user daniel:secret http://example.com/</span><br><span class="line">curl --negotiate --user daniel:secret http://example.com/</span><br><span class="line">curl --ntlm --user daniel:secret http://example.com/</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2018/06/16/how-to-write-a-custom-eslint-rule/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/16/how-to-write-a-custom-eslint-rule/" itemprop="url">
                  如何写编写自定义 ESLint 规则
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-06-16 13:55:49 / Modified: 19:06:45" itemprop="dateCreated datePublished" datetime="2018-06-16T13:55:49+08:00">2018-06-16</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/eslint/" itemprop="url" rel="index"><span itemprop="name">eslint</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><strong>因为译者还没有写过这个插件, 而且英文水平有限, 所以这篇文章里还存在很多错误, 也有部分看不懂而没法翻译的地方, 读者如果愿意斧正的话， 请发邮件到我的邮箱 <a href="mailto:olafcheng@gmail.com" target="_blank" rel="noopener">olafcheng@gmail.com</a></strong></p>
<p>后续我在发现文章里的更正确的翻译后, 也会更新这篇译文.</p>
</blockquote>
<blockquote>
<p>原文地址：<a href="https://eslint.org/docs/developer-guide/working-with-rules" target="_blank" rel="noopener">https://eslint.org/docs/developer-guide/working-with-rules</a></p>
</blockquote>
<p><strong>注意：</strong> 这个文章里，主要覆盖率 ESLint &gt;= 3.0.0 版本的规则，如果想要看已废弃的规则，请点<a href="https://eslint.org/docs/developer-guide/working-with-rules-deprecated" target="_blank" rel="noopener">这里</a>.</p>
<p>每个规则，在 ESLint 里都有以这个规则为标识符为开头命名的三个文件(比如, <code>no-extra-semi</code>).</p>
<ul>
<li>在 <code>lib/rules</code> 目录下： 一个源文件（例如，<code>no-extra-semi.js</code>）</li>
<li>在 <code>tests/lib/rules</code> 目录下: 一个测试文件 (例如, <code>no-extra-semi.js</code>)</li>
<li>在 <code>docs/rules</code> 目录: 一个 markdown 文档文件 (例如, <code>no-extra-semi</code>)</li>
</ul>
<p><strong>需要注意的重点：</strong>如果你想要给 ESLint 仓库提交一个<code>核心</code>规则，你<strong>必须</strong>遵循下列约定.</p>
<p>下面是规则源文件的基本格式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @fileoverview Rule to disallow unnecessary semicolons</span></span><br><span class="line"><span class="comment"> * @author Nicholas C. Zakas</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Rule Definition</span></span><br><span class="line"><span class="comment">//------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123;</span><br><span class="line">        docs: &#123;</span><br><span class="line">            description: <span class="string">"disallow unnecessary semicolons"</span>,</span><br><span class="line">            category: <span class="string">"Possible Errors"</span>,</span><br><span class="line">            recommended: <span class="literal">true</span>,</span><br><span class="line">            url: <span class="string">"https://eslint.org/docs/rules/no-extra-semi"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        fixable: <span class="string">"code"</span>,</span><br><span class="line">        schema: [] <span class="comment">// no options</span></span><br><span class="line">    &#125;,</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="comment">// callback functions</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="规则基础"><a href="#规则基础" class="headerlink" title="规则基础"></a>规则基础</h2><p>规则的源文件会 exports 出一个带有下列字段的 object：</p>
<p><code>meta</code> (object) 包含了规则的元数据:</p>
<ul>
<li><p><code>docs</code> (object) 对于 ESLint 的核心规则来说，是必须的:</p>
</li>
<li><ul>
<li><code>description</code> (string) 提供了会显示在<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">规则目录</a>里的简短描述</li>
</ul>
</li>
<li><ul>
<li><code>category</code> (string) 规定了这个规则在<a href="https://eslint.org/docs/rules/" target="_blank" rel="noopener">规则目录</a>中分数哪个部分</li>
</ul>
</li>
<li><ul>
<li><code>recommended</code> (boolean) 是否需要包含在<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">配置文件</a>的 “extends”: “eslint:recommended” 这个属性默认开启的规则里.</li>
</ul>
</li>
<li><ul>
<li><code>url</code> (string) 规定了可以在哪个地方可以访问这个规则的详细信息</li>
</ul>
</li>
</ul>
<p>在自定义规则或者插件里，可以不包含 <code>docs</code> 字段，其实其他字段也是一样的，可以去除掉.</p>
<ul>
<li><p><code>fixable</code> (string) 可选值有 “code” 和 “whitespace”, 这个字段决定当在命令行里加上<code>--fix</code>参数的时候, 要不要自动的纠正报错的地方</p>
<p><strong>注意:</strong> 如果没有 <code>fixable</code> 字段, 就算在实现规则的时候写了 <code>fix</code> 函数, ESLint 也不会对报错的地方<a href="https://eslint.org/docs/developer-guide/working-with-rules#applying-fixes" target="_blank" rel="noopener">进行纠正</a>. 如果规则是不可自动纠正的话，请不要写 <code>fixable</code> 这个字段.</p>
</li>
</ul>
<ul>
<li><p><code>schema</code> (array) 这个字段可以约束<a href="https://eslint.org/docs/developer-guide/working-with-rules#options-schemas" target="_blank" rel="noopener">规则的写法</a>, 以便 ESLint 发现有无效的<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">规则配置文件</a> 时进行报错.</p>
<ul>
<li><code>deprecated</code> (boolean) 用来表明这个规则是否已经被废弃. 如果规则还正在使用的话，请不要写这个字段.</li>
</ul>
</li>
</ul>
<p><code>create</code> (function) 返回一个用来遍历(<code>visit</code>) JavaScript 代码的抽象语法树(一个按照<a href="https://github.com/estree/estree" target="_blank" rel="noopener">ES 树</a>来定义的 AST)节点的对象，这个对象上会挂有一些方法，以便 ESLint 在 AST 上调用:</p>
<ul>
<li>if a key is a node type or a selector, ESLint calls that visitor function while going down the tree</li>
<li>if a key is a node type or a selector plus :exit, ESLint calls that visitor function while going up the tree</li>
<li>if a key is an event name, ESLint calls that handler function for code path analysis</li>
</ul>
<p>规则可以利用当前的代码片段和附近的 AST 来报错或者纠正问题.</p>
<p>下面是 <a href="https://eslint.org/docs/rules/array-callback-return" target="_blank" rel="noopener">array-call-back</a> 规则的一些方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkLastSegment</span> (<span class="params">node</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// report problem for function if last code path segment is reachable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123; ... &#125;,</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// declare the state of the rule</span></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ReturnStatement: <span class="function"><span class="keyword">function</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// at a ReturnStatement node while going down</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// at a function expression node while going up:</span></span><br><span class="line">            <span class="string">"FunctionExpression:exit"</span>: checkLastSegment,</span><br><span class="line">            <span class="string">"ArrowFunctionExpression:exit"</span>: checkLastSegment,</span><br><span class="line">            onCodePathStart: <span class="function"><span class="keyword">function</span> (<span class="params">codePath, node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// at the start of analyzing a code path</span></span><br><span class="line">            &#125;,</span><br><span class="line">            onCodePathEnd: <span class="function"><span class="keyword">function</span>(<span class="params">codePath, node</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// at the end of analyzing a code path</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="上下文-Object"><a href="#上下文-Object" class="headerlink" title="上下文 Object"></a>上下文 Object</h2><p><code>context</code> 对象包含了一些额外的函数，可以帮助规则来完成工作. 顾名思义，<code>context</code> 对象包含了跟规则相关的一些上下文的信息.<code>context</code> 对象包含如下的字段：</p>
<ul>
<li><code>parserOptions</code> - 在运行的时候，将要用到的解析规则的参数(更多细节看<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">这里</a>)</li>
<li><code>id</code> - 规则 ID.</li>
<li><code>options</code> - 给这个规则传递的<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">配置信息</a>. 这个数组不包含规则本身. 详细信息看<a href="https://eslint.org/docs/developer-guide/working-with-rules#contextoptions" target="_blank" rel="noopener">这里</a>.</li>
<li>settings - 来自配置信息的<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">共享设置</a>.</li>
<li>parserPath - 来自配置信息的 parser 的名字</li>
<li>parserServices - 一个包含了规则的解析器服务的对象. 默认的解析器并不提供任何服务. 然而, 如果一个规则想要使用自定义的解释器的话, 它就可以通过 <code>parserServices</code> 来访问自定义解释器提供的各种结果. (例如, TypeScript 的解释器可以计算出来一个给定的节点的数据类型)</li>
</ul>
<p>除此之外, <code>context</code> 对象还含有如下的方法:</p>
<ul>
<li><code>getAncestors()</code> - 返回一个包含了所有遍历过的父节点的数组, 这些父节点从 AST 的根节点开始, 直到这个节点的直接父节点. 这个数组不包含这个节点本身.</li>
<li><code>getDeclaredVariables(node)</code> - 返回给定节点定义的<a href="https://eslint.org/docs/developer-guide/scope-manager-interface" target="_blank" rel="noopener">变量</a>的列表. 这个信息可以用来跟踪变量的引用信息.</li>
<li><ul>
<li>如果给定节点是一个 <code>VariableDeclaration</code>, 返回这个变量声明里声明的所有变量.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是一个 <code>VariableDeclarator</code>, 返回这个变量声明里声明的所有变量(译者注: 两者的区别可以看<a href="https://juejin.im/post/582425402e958a129926fcb4" target="_blank" rel="noopener">这里</a>).</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是一个 <code>FunctionDeclaration</code> 或者 <code>FunctionExpression</code>, 返回给参数传递的参数以及函数的 <code>name</code> 属性的值.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是一个 <code>ArrowFunctionExpression</code>, 会返回传递给这个函数的参数.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是 <code>ClassDeclaration</code> 或者 <code>ClassDeclaration</code>, 返回类的 name 属性的值.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是 <code>CatchClause</code>, 返回异常处理函数里的变量.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是 <code>ImportDeclaration</code>, 返回这个语句定义的变量.</li>
</ul>
</li>
<li><ul>
<li>如果给定节点是 <code>ImportSpecifier</code>, <code>ImportDefaultSpecifier</code> 或者 <code>ImportNamespaceSpecifier</code>, 返回定义的变量.</li>
</ul>
</li>
<li><ul>
<li>否则, 给定节点什么变量都没有定义的话, 会返回一个空数组.</li>
</ul>
</li>
<li><code>getFilename()</code> - 返回源文件的名称.</li>
<li><code>getScope()</code> - 返回给定节点的<a href="https://eslint.org/docs/developer-guide/scope-manager-interface" target="_blank" rel="noopener">作用域</a>. 作用域的信息可以用来跟踪变量.</li>
<li><code>getSourceCode()</code> - 返回基于源文件处理好的, 可以让 ESLint 进行工作的一个源文件对象.</li>
<li><code>markVariableAsUsed(name)</code> - 把给定的作用域中的一个变量标记为已使用过. 这个会影响<a href="https://eslint.org/docs/rules/no-unused-vars" target="_blank" rel="noopener">no-unused-vars</a>规则. 如果这个变量在被标记以前的状态已经是被使用过了, 就返回 <code>true</code>, 否则返回 <code>false</code>.</li>
<li><code>report(descriptor)</code> - 报告代码中存在的问题 (点<a href="https://eslint.org/docs/developer-guide/working-with-rules#contextreport" target="_blank" rel="noopener">这里</a>看对应的部分).</li>
</ul>
<p><strong>注意:</strong> 在 ESLint 的早期版本, <code>context</code> 对象还支持额外的一些方法. 这些方法都已经在新的格式里被移除了, 并且不应该再被依赖了.</p>
<h3 id="context-report"><a href="#context-report" class="headerlink" title="context.report()"></a>context.report()</h3><p>写自定义规则的过程里, 最常用的一个方法是 <code>context.report()</code>, 这个方法可以报告一个 warning 或者 error(取决于你的配置文件怎么用的). 这个方法只接受一个对象作为参数, 这个对象, 包含如下的字段:</p>
<ul>
<li><code>message</code> - 问题的描述.</li>
<li><code>node</code> - (可选) 与问题相关的 AST. 如果这个选项和 <code>loc</code> 都没有被指定, 这个节点的开始的地方, 就会被被当作问题的定位.</li>
<li><code>loc</code> - (可选) 一个表示问题定位信息的对象. 如果 <code>loc</code> 和 <code>node</code> 都被指定了, ESLint 会用 <code>loc</code> 参数来定位问题, 而不是 <code>node</code>.</li>
<li><ul>
<li><code>start</code> - 一个对象, 定位了问题从哪里开始.</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>line</code> - 从 1 开始数的行数, 用于表示问题在第几行开始发生.</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>column</code> - 从 0 开始数的列数, 用于表示问题在第几列开始发生.</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><code>end</code> - 一个对象, 定位了问题在哪里结束.</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>line</code> - 从 1 开始数的行数, 用于表示问题在第几行结束.</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><code>column</code> - 从 0 开始数的列数, 用于表示问题在第几列开始结束.</li>
</ul>
</li>
</ul>
</li>
<li><code>data</code> - (可选) 错误信息的<a href="https://eslint.org/docs/developer-guide/working-with-rules#using-message-placeholders" target="_blank" rel="noopener">占位符</a>数据.</li>
<li><code>fix</code> - (可选) 一个可以用来纠正问题的函数.<br>注意, 参数里, <code>node</code> 与 <code>loc</code> 至少需要配置一个.</li>
</ul>
<p>最简单的报错的例子就是直接用 <code>node</code> 和 <code>message</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context.report(&#123;</span><br><span class="line">    node: node,</span><br><span class="line">    message: <span class="string">"Unexpected identifier"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>node 变量包括了查错所需要的必要信息, 包括行列信息, 还有简单的源代码的文本.</p>
<h3 id="用-message-占位符"><a href="#用-message-占位符" class="headerlink" title="用 message 占位符"></a>用 message 占位符</h3><p>你也可以用占位符:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.report(&#123;</span><br><span class="line">    node: node,</span><br><span class="line">    message: <span class="string">"Unexpected identifier: &#123;&#123; identifier &#125;&#125;"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        identifier: node.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意 message 里变量前后的空格是可选的.</p>
<p>node 里包含的信息, 同上.</p>
<h3 id="messageIds"><a href="#messageIds" class="headerlink" title="messageIds"></a><code>messageId</code>s</h3><p>你可以在 <code>context.report()</code> 和测试文件里都打出报告信息, 也可以用一个 <code>messageIds</code> 来代替.</p>
<p>这样你就能避免重复打印信息了. It also prevents errors reported in different sections of your rule from having out-of-date messages.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in your rule</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123;</span><br><span class="line">        messages: &#123;</span><br><span class="line">            avoidName: <span class="string">"Avoid using variables named '&#123;&#123; name &#125;&#125;'"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    create(context) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            Identifier(node) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node.name === <span class="string">"foo"</span>) &#123;</span><br><span class="line">                    context.report(&#123;</span><br><span class="line">                        node,</span><br><span class="line">                        messageId: <span class="string">"avoidName"</span>,</span><br><span class="line">                        data: &#123;</span><br><span class="line">                            name: <span class="string">"foo"</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// in the file to lint:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//  ^ error: Avoid using variables named 'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// In your tests:</span></span><br><span class="line"><span class="keyword">var</span> rule = <span class="built_in">require</span>(<span class="string">"../../../lib/rules/my-rule"</span>);</span><br><span class="line"><span class="keyword">var</span> RuleTester = <span class="built_in">require</span>(<span class="string">"eslint"</span>).RuleTester;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ruleTester = <span class="keyword">new</span> RuleTester();</span><br><span class="line">ruleTester.run(<span class="string">"my-rule"</span>, rule, &#123;</span><br><span class="line">    valid: [<span class="string">"bar"</span>, <span class="string">"baz"</span>],</span><br><span class="line"></span><br><span class="line">    invalid: [</span><br><span class="line">        &#123;</span><br><span class="line">            code: <span class="string">"foo"</span>,</span><br><span class="line">            errors: [</span><br><span class="line">                &#123;</span><br><span class="line">                    messageId: <span class="string">"avoidName"</span>,</span><br><span class="line">                    data: &#123;</span><br><span class="line">                        name: <span class="string">"foo"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="进行修正"><a href="#进行修正" class="headerlink" title="进行修正"></a>进行修正</h3><p>如果你想让 ESLint 在发现报告问题的时候, 尝试自动修正问题, 可以给 <code>context.report()</code> 指定一个 <code>fix</code> 函数. <code>fix</code> 函数接受一个用来修正的 <code>fixer</code> 对象作为参数, 用来修正问题. 比如:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context.report(&#123;</span><br><span class="line">    node: node,</span><br><span class="line">    message: <span class="string">"Missing semicolon"</span>,</span><br><span class="line">    fix: <span class="function"><span class="keyword">function</span>(<span class="params">fixer</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> fixer.insertTextAfter(node, <span class="string">";"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这个 <code>fix()</code> 函数可以在给定节点后面插入一个分号. 要注意的是, 修正不是立即就进行的, 而且如果跟其他的修正函数有冲突的话, 这个修正可能不会进行. 在修正完以后, ESLint 会在修正完的代码上重新运行所有启用的校验规则, 所以可能会引发更多的修正. 在所有能被修正的问题都被修正完以前, 这个过程最多会重复 10 次. 在这以后, 问题会和平常一样被报告出来, 而不会自动修正.</p>
<p>Important: Unless the rule exports the meta.fixable property, ESLint does not apply fixes even if the rule implements fix functions.</p>
<p><strong>重要:</strong> 即便实现了 <code>fix</code> 函数, ESLint 也不会启用修正功能, 除非规则 <a href="https://eslint.org/docs/developer-guide/working-with-rules#rule-basics" target="_blank" rel="noopener">exports</a> 了 <code>meta.fixable</code> 字段.</p>
<p><code>fixer</code> 对象包含以下方法:</p>
<ul>
<li><code>insertTextAfter(nodeOrToken, text)</code> - 在给定节点或者 token 后, 插入文本</li>
<li><code>insertTextAfterRange(range, text)</code> - 在给定的 range 后插入文本</li>
<li><code>insertTextBefore(nodeOrToken, text)</code> - 在给定节点或者 token 前, 插入文本</li>
<li><code>insertTextBeforeRange(range, text)</code> - 在给定的 range 前插入文本</li>
<li><code>remove(nodeOrToken)</code> - 移除给定节点或者 token</li>
<li><code>removeRange(range)</code> - 在指定节点或者 token 中, 移除给定文本</li>
<li><code>replaceText(nodeOrToken, text)</code> - 替换给定节点或者 token 中的文本</li>
<li><code>replaceTextRange(range, text)</code> - 替换给定 range 中的文本</li>
</ul>
<p>上面这些方法返回了一个 <code>fixing</code> 对象. <code>fix()</code> 函数可以返回如下值:</p>
<ul>
<li>一个 <code>fixing</code> 对象.</li>
<li>一个包含了 <code>fixing</code> 对象的数组.</li>
<li>一个可迭代枚举 <code>fixing</code> 对象的对象. 也就是说, <code>fix()</code> 对象可以是一个生成器.</li>
</ul>
<p>如果你让 <code>fix()</code> 函数返回了多个 <code>fixing</code> 对象, 这些 <code>fixing</code> 对象不能是重复的.</p>
<p>有关修正的最佳实践:</p>
<ol>
<li>避免任何能改变运行时行为的修正, 以避免代码停止运行.</li>
<li>作尽可能小范围的修正. 如果有些修正不必要的繁杂, 可能会导致跟其他的修正冲突, 于是这个修正就不会被应用了.</li>
<li>每个 message 只做一个修正. 这个是强制的, 因为在每个 <code>fix()</code> 函数执行完以后, 你都需要返回修正操作的结果.</li>
<li>既然在每次修复完成后, 都会重新运行所有的规则进行校验, 那在修正完成后, 就没有单独检查修正是否引起了新的错误的必要了.<ul>
<li><ul>
<li>比如, 假设修正函数想让一个对象的键被引号包裹起来, 但是这个修正函数并不知道用户的脚本是用单引号还是双引号格式化的.<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(&#123; <span class="attr">foo</span> : <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// should get fixed to either</span></span><br><span class="line"></span><br><span class="line">(&#123; <span class="string">'foo'</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line">(&#123; <span class="string">"foo"</span>: <span class="number">1</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li><ul>
<li>这个修正函数选择的可能是单引号或者双引号里的其中一个. 如果猜错了, 修正后的代码会报引号相关的问题, 并且可以被 <a href="https://eslint.org/docs/rules/quotes" target="_blank" rel="noopener"><code>quotes</code></a> 规则自动修正.</li>
</ul>
</li>
</ul>
<h3 id="context-options"><a href="#context-options" class="headerlink" title="context.options"></a>context.options</h3><p>有些规则为了正常的工作, 需要配置选项. 这些选项会出现在配置信息里(<code>.eslintrc</code>, 命令行, 后者注释中). 比如:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>quotes</code> 规则在这个例子里有一个选项, <code>&quot;double&quot;</code>(<code>error</code> 是错误级别). 在写修正函数的时候, 可以用<code>context.options</code> 这个属性来得到一个这个规则的配置信息的数组. 在这个例子里, 访问 <code>context.options[0]</code> 会得到 <code>&quot;double&quot;</code>:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> isDouble = (context.options[<span class="number">0</span>] === <span class="string">"double"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>由于<code>context.options</code>刚好是一个数组, 你在拿到配置信息的时候, 可以直接得到到底有多少条配置被应用在这个规则上. 记住, 错误级别不属于 <code>context.options</code>, 错误级别在一个规则里也是不可以被获取或者被修改的.</p>
<p>当你的代码要读取配置信息的时候, 确保设置好了一些默认值, 以防使用这个规则的人没有传递任何配置信息.</p>
<h3 id="context-getSourceCode"><a href="#context-getSourceCode" class="headerlink" title="context.getSourceCode()"></a>context.getSourceCode()</h3><p>如果你想要得到跟你正在 lint 的源代码的更多相关信息, 需要访问 <code>SourceCode</code> 这个对象. 通过调用 <code>getSourceCode()</code> 方法, 你可以随时获得 <code>SourceCode</code> 这个对象:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    create: <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sourceCode = context.getSourceCode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一旦拿到了 <code>SourceCode</code> 的实例, 就可以调用这个对象上的方法来操作代码了:</p>
<ul>
<li><code>getText(node)</code> - 返回给定节点的源代码. 如果不传递 <code>node</code> 参数, 会得到整份源代码.</li>
<li><code>getAllComments()</code> - 返回一个包含源代码中所有注释的数组.</li>
<li><code>getCommentsBefore(nodeOrToken)</code> - returns an array of comment tokens that occur directly before the given node or token.</li>
<li><code>getCommentsAfter(nodeOrToken)</code> - returns an array of comment tokens that occur directly after the given node or token.</li>
<li><code>getCommentsInside(node)</code> - 返回给定节点中的所有注释.</li>
<li><code>getJSDocComment(node)</code> - 返回给定节点中的 JSDoc 注释节点, 如果没有的话, 就返回 <code>null</code>.</li>
<li><code>isSpaceBetweenTokens(first, second)</code> - 如果在给定的两个节点之间有空格, 返回 <code>true</code>.</li>
<li><code>getFirstToken(node, skipOptions)</code> - 返回给定节点中包含的第一个分词.</li>
<li><code>getFirstTokens(node, countOptions)</code> - returns the first count tokens representing the given node.</li>
<li><code>getLastToken(node, skipOptions)</code> - 返回给定节点里的最后一个分词.</li>
<li><code>getLastTokens(node, countOptions)</code> - returns the last count tokens representing the given node.</li>
<li><code>getTokenAfter(nodeOrToken, skipOptions)</code> - 返回给定节点或者分词后的第一个分词.</li>
<li><code>getTokensAfter(nodeOrToken, countOptions)</code> - returns count tokens after the given node or token.</li>
<li><code>getTokenBefore(nodeOrToken, skipOptions)</code> - 返回给定节点或者分词前的第一个分词.</li>
<li><code>getTokensBefore(nodeOrToken, countOptions)</code> - returns count tokens before the given node or token.</li>
<li><code>getFirstTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions)</code> - 返回两个给定节点或者分词间的第一个分词.</li>
<li><code>getFirstTokensBetween(nodeOrToken1, nodeOrToken2, countOptions)</code> - returns the first count tokens between two nodes or tokens.</li>
<li><code>getLastTokenBetween(nodeOrToken1, nodeOrToken2, skipOptions)</code> - 返回两个给定节点或者分词间的最后一个分词.</li>
<li><code>getLastTokensBetween(nodeOrToken1, nodeOrToken2, countOptions)</code> - returns the last count tokens between two nodes or tokens.</li>
<li><code>getTokens(node)</code> - 返回给定节点的所有分词.</li>
<li><code>getTokensBetween(nodeOrToken1, nodeOrToken2)</code> - 返回两个给定节点间的所有分词.</li>
<li><code>getTokenByRangeStart(index, rangeOptions)</code> - 返回以给定索引为开始的所有分词.</li>
<li><code>getNodeByRangeIndex(index)</code> - 返回包含给定源代码索引的层次最深的一个节点.</li>
<li><code>getLocFromIndex(index)</code> - 返回给定源代码索引的坐标信息, 包含以 1 开始的行坐标 <code>line</code>与以 0 开始的列坐标 <code>column</code>.</li>
<li><code>getIndexFromLoc(loc)</code> - 返回给定坐标定位到的源代码的坐标对象, <code>loc</code> 是一个坐标对象, 其包含以 1 开始的行坐标 <code>line</code> 与以 0 开始的列坐标 <code>column</code>.</li>
<li><code>commentsExistBetween(nodeOrToken1, nodeOrToken2)</code> - 如果给定节点或分词间, 存在注释, 返回 <code>true</code>.</li>
</ul>
<blockquote>
<p><code>skipOptions</code> 是一个有 3 个字段的对象, 包括 <code>skip</code>, <code>includeComments</code> 和 <code>filter</code>. 默认值为 <code>{skip: 0, includeComments: false, filter: null}</code>.</p>
<ul>
<li><code>skip</code> 是一个正整数, 表示跳过的分词的数量. 如果 <code>filter</code> 参数也有数值, 那么 <code>filter</code> 过滤掉的分词不会被计数在需要跳过的分词里.</li>
<li><code>includeComments</code> 是一个布尔值, 是一个标志位, 用来标记返回结果里要不要出现注释分词.</li>
<li><code>filter</code> 是一个第一个参数为分词的函数, 如果函数返回 <code>false</code>, 那么结果里就会排除掉这个分词.</li>
</ul>
<p><code>countOptions</code> 是一个拥有 3 个字段的对象; <code>count</code>, <code>includeComments</code>, 以及 <code>filter</code>. 默认值是 <code>{count: 0, includeComments: false, filter: null}</code>.</p>
<ul>
<li><code>count</code> 是一个正整数, 值为返回的所有分词的数量.</li>
<li><code>includeComments</code> 是一个布尔值, 是一个标志位, 用来标记返回结果里要不要出现注释分词.</li>
<li><code>filter</code> 是一个第一个参数为分词的函数, 如果函数返回 <code>false</code>, 那么结果里就会排除掉这个分词.<br><code>rangeOptions</code> 是包含一个字段的对象: <code>includeComments</code>.</li>
<li><code>includeComments</code> 是一个布尔值, 是一个标志位, 用来标记返回结果里要不要出现注释分词.</li>
</ul>
</blockquote>
<p>还有一些别的你可以访问的字段：</p>
<ul>
<li><code>hasBOM</code> - 用来表示源代码是否含有 Unicode BOM 头</li>
<li><code>text</code> - 需要被 lint 的完整的文本. Unicode BOM 头已经被去掉了.</li>
<li><code>ast</code> - 需要被 lint 的代码的 AST.</li>
<li><code>scopeManager</code> - 代码的<a href="https://eslint.org/docs/developer-guide/scope-manager-interface" target="_blank" rel="noopener">作用域管理</a>对象.</li>
<li><code>visitorKeys</code> - 用于遍历这个 AST 的访问者 key.</li>
<li><code>lines</code> - 代码分成行的数组, 分行是根据指定的换行符来进行的.</li>
</ul>
<p>通过 <code>SourceCode</code> 对象, 你可以获得更多有关你要 lint 的代码的信息.</p>
<h4 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h4><p>下列这些方法已经被废弃了, 并且在未来的版本里, 会从 ESLint 中移除掉:</p>
<ul>
<li><code>getComments()</code> - 被 <code>getCommentsBefore()</code>, <code>getCommentsAfter()</code>, 以及 <code>getCommentsInside()</code> 方法取代了</li>
<li><code>getTokenOrCommentBefore()</code> - 被带有 <code>{ includeComments: true }</code> 参数的 <code>getTokenBefore()</code> 方法取代了</li>
<li><code>getTokenOrCommentAfter()</code> - 被带有 <code>{ includeComments: true }</code> 参数的 <code>getTokenAfter()</code> 方法取代了</li>
</ul>
<h3 id="参数纲要"><a href="#参数纲要" class="headerlink" title="参数纲要"></a>参数纲要</h3><p>自定义的规则可能导出 <code>schema</code> 字段, 这个字段是一个<a href="http://json-schema.org/" target="_blank" rel="noopener">基于 JSON 格式的 schema</a> 描述, 这个 schema 会被用于校验用户提供给 ESLint 的参数的有效性, 避免用户给 <code>context.options</code> 传递一些无效或者异常的输入.</p>
<p>有两种导出 <code>schema</code> 的方式. 第一种是, 导出完整的 JSON schema 对象, 这个对象枚举了所有可能的规则参数的情况, 包括了错误级别(error level)第一个参数, 后面再加上几个额外的参数的情况.</p>
<p>然而, 为了简化 schema 的编写, 规则也可以在可选参数的后面跟上一个表示可以作为参数值的数组, ESLint 会首先对需要的错误级别进行校验. 比如, <code>yoda</code> 规则接收主要参数, 以及带有命名好的字段的额外的参数对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// "yoda": [2, "never", &#123; "exceptRange": true &#125;]</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    meta: &#123;</span><br><span class="line">        schema: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"enum"</span>: [<span class="string">"always"</span>, <span class="string">"never"</span>]</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"type"</span>: <span class="string">"object"</span>,</span><br><span class="line">                <span class="string">"properties"</span>: &#123;</span><br><span class="line">                    <span class="string">"exceptRange"</span>: &#123;</span><br><span class="line">                        <span class="string">"type"</span>: <span class="string">"boolean"</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="string">"additionalProperties"</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        ];</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子里, 错误级别被假定为了第一个参数. 紧随其后的, 是第一个可选参数, 参数的值可能是 <code>&quot;always&quot;</code> 或者 <code>&quot;never&quot;</code>. 最后跟着的是一个对象形式的可选的参数, 这个对象表示的是, 这个参数名为 <code>exceptRange</code>, 值为布尔型.</p>
<p>为了进一步了解 JSON schema, 我们建议你先从看一些<a href="http://json-schema.org/examples.html" target="_blank" rel="noopener">例子</a>开始, 并且读一下 <a href="http://spacetelescope.github.io/understanding-json-schema/" target="_blank" rel="noopener">Understanding JSON Schema</a> 这本书(免费的).</p>
<p><strong>Note:</strong> 目前你需要使用完整的 JSON Schema 对象而不是数组, 以免你的 schema 里含有引用($ref), 因为在这种情况下, ESLint 会把数组转换为单个的 schema 而不更新引用, 结果就会导致出错(引用会被忽略掉).</p>
<h3 id="得到源码"><a href="#得到源码" class="headerlink" title="得到源码"></a>得到源码</h3><p>如果你需要对 JavaScript 源代码进行操作, 可以调用 <code>sourceCode.getText()</code> 来得到源代码. 这个方法的工作方式如下:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get all source</span></span><br><span class="line"><span class="keyword">var</span> source = sourceCode.getText();</span><br><span class="line"></span><br><span class="line"><span class="comment">// get source for just this AST node</span></span><br><span class="line"><span class="keyword">var</span> nodeSource = sourceCode.getText(node);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get source for AST node plus previous two characters</span></span><br><span class="line"><span class="keyword">var</span> nodeSourceWithPrev = sourceCode.getText(node, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// get source for AST node plus following two characters</span></span><br><span class="line"><span class="keyword">var</span> nodeSourceWithFollowing = sourceCode.getText(node, <span class="number">0</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<p>如果 AST 没能提供正确的数据的话(比如逗号、分号、圆括号的定位信息等等), 你就可以直接对 JavaScript 文本进行操作来得到这些.</p>
<h3 id="访问注释"><a href="#访问注释" class="headerlink" title="访问注释"></a>访问注释</h3><p>因为注释在技术层面上来讲, 并不属于 AST 的一部分, 所以 ESlint 提供了一些访问注释的方法:</p>
<p>sourceCode.getAllComments()<br>这个方法返回一个数组, 数组里包含了从程序里找到的那些注释. 当开发者不关心注释的定位信息, 而是需要查看一下所有的注释的时候, 这个方法尤为有用.</p>
<p>sourceCode.getCommentsBefore(), sourceCode.getCommentsAfter(), and sourceCode.getCommentsInside()<br>这些方法依次返回在给定节点之前、之后以及节点内部的注释. 当开发者想要查看跟给定节点或者分词相关的注释的时候, 这个方法尤为有用.</p>
<p>记住, 这些方法的结果是需要经过计算才能得到的.</p>
<h4 id="遍历分词的方法"><a href="#遍历分词的方法" class="headerlink" title="遍历分词的方法"></a>遍历分词的方法</h4><p>其实, 注释也可以通过很多的 <code>sourceCode</code> 对象的方法, 加上 <code>includeCommecnts</code> 参数来调用, 来进行访问.</p>
<h3 id="访问-Shebangs"><a href="#访问-Shebangs" class="headerlink" title="访问 Shebangs"></a>访问 Shebangs</h3><p>Shebangs 是类型为 <code>&quot;Shebang&quot;</code> 的分词. 其会被上面提到的这些方法, 当作注释来识别.</p>
<h3 id="访问代码路径"><a href="#访问代码路径" class="headerlink" title="访问代码路径"></a>访问代码路径</h3><p>ESLint 在遍历 AST 的时候会分析代码路径. 你可以通过跟代码路径相关的 5 个事件, 来访问代码路径.<br><a href="https://eslint.org/docs/developer-guide/code-path-analysis" target="_blank" rel="noopener">细节看这里</a></p>
<h2 id="对规则单元测试"><a href="#对规则单元测试" class="headerlink" title="对规则单元测试"></a>对规则单元测试</h2><p>在提交 ESLint 的核心规则的时候, 为了被 ESLint 库接受, 必须对每个规则增加一系列的单测文件. 单测文件跟规则的源文件同名, 不过放在 <code>tests/lib/</code> 文件夹下. 比如, 如果源文件是 <code>lib/rules/foo.js</code>, 那测试文件就是 <code>tests/lib/rules/foo.js</code>.</p>
<p>ESLint 提供了 <a href="https://eslint.org/docs/developer-guide/nodejs-api" target="_blank" rel="noopener"><code>RuleTester</code></a> 工具让写单测变得更简单.</p>
<h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>为了保持 lint 进程的高效性, 以及对开发者造成尽可能小的影响, 测试一下新规则以及对现有规则的修改对性能的影响, 是很有用的.</p>
<h3 id="总体性能"><a href="#总体性能" class="headerlink" title="总体性能"></a>总体性能</h3><p>当开发 ESLint 核心库的时候, <code>npm run perf</code> 命令会显示出来所有规则都执行的时候, 运行所需时间的概括情况.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">'master'</span></span><br><span class="line"></span><br><span class="line">$ npm run perf</span><br><span class="line">CPU Speed is 2200 with multiplier 7500000</span><br><span class="line">Performance Run <span class="comment">#1:  1394.689313ms</span></span><br><span class="line">Performance Run <span class="comment">#2:  1423.295351ms</span></span><br><span class="line">Performance Run <span class="comment">#3:  1385.09515ms</span></span><br><span class="line">Performance Run <span class="comment">#4:  1382.406982ms</span></span><br><span class="line">Performance Run <span class="comment">#5:  1409.68566ms</span></span><br><span class="line">Performance budget ok:  1394.689313ms (<span class="built_in">limit</span>: 3409.090909090909ms)</span><br><span class="line"></span><br><span class="line">$ git checkout my-rule-branch</span><br><span class="line">Switched to branch <span class="string">'my-rule-branch'</span></span><br><span class="line"></span><br><span class="line">$ npm run perf</span><br><span class="line">CPU Speed is 2200 with multiplier 7500000</span><br><span class="line">Performance Run <span class="comment">#1:  1443.736547ms</span></span><br><span class="line">Performance Run <span class="comment">#2:  1419.193291ms</span></span><br><span class="line">Performance Run <span class="comment">#3:  1436.018228ms</span></span><br><span class="line">Performance Run <span class="comment">#4:  1473.605485ms</span></span><br><span class="line">Performance Run <span class="comment">#5:  1457.455283ms</span></span><br><span class="line">Performance budget ok:  1443.736547ms (<span class="built_in">limit</span>: 3409.090909090909ms)</span><br></pre></td></tr></table></figure></p>
<h3 id="单个规则的性能"><a href="#单个规则的性能" class="headerlink" title="单个规则的性能"></a>单个规则的性能</h3><p>ESLint 有一个内置的方法来对单个的规则的性能进行跟踪. 设置一下 <code>TIMING</code> 环境变量, 就会触发跟踪结果的显示, 这些内容收集了耗时最长的十个规则里, 每个规则单独的耗时, 并且通过计算占总的规则的时间的百分比, 来标示出对性能的影响的相关性.<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ TIMING=1 eslint lib</span><br><span class="line">Rule                    | Time (ms) | Relative</span><br><span class="line">:-----------------------|----------:|--------:</span><br><span class="line">no-multi-spaces         |    52.472 |     6.1%</span><br><span class="line">camelcase               |    48.684 |     5.7%</span><br><span class="line">no-irregular-whitespace |    43.847 |     5.1%</span><br><span class="line">valid-jsdoc             |    40.346 |     4.7%</span><br><span class="line">handle-callback-err     |    39.153 |     4.6%</span><br><span class="line">space-infix-ops         |    35.444 |     4.1%</span><br><span class="line">no-undefined            |    25.693 |     3.0%</span><br><span class="line">no-shadow               |    22.759 |     2.7%</span><br><span class="line">no-empty-class          |    21.976 |     2.6%</span><br><span class="line">semi                    |    19.359 |     2.3%</span><br></pre></td></tr></table></figure></p>
<p>如果想要明确的测试某个规则, 可以对命令加上 <code>--no-eslintrc</code> 和 <code>--rule</code> 参数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ TIMING=1 eslint --no-eslintrc --rule <span class="string">"quotes: [2, 'double']"</span> lib</span><br><span class="line">Rule   | Time (ms) | Relative</span><br><span class="line">:------|----------:|--------:</span><br><span class="line">quotes |    18.066 |   100.0%</span><br></pre></td></tr></table></figure></p>
<h2 id="规则命名约定"><a href="#规则命名约定" class="headerlink" title="规则命名约定"></a>规则命名约定</h2><p>ESLint 的规则命名约定, 是相当简单的:</p>
<ul>
<li>如果你的规则是为了禁用某些东西, 请用 <code>no-</code> 作为前缀, 比如 <code>no-eval</code> 表示禁止使用 <code>eval()</code>, <code>no-debugger</code> 表示禁止使用 <code>debugger</code>.</li>
<li>如果你的规则是为了强制要求包含某些东西, 不要加前缀, 只要用简写来命名就行了.</li>
<li>在单词之间用短破折号(-).</li>
</ul>
<h2 id="运行时规则"><a href="#运行时规则" class="headerlink" title="运行时规则"></a>运行时规则</h2><p>之所以 ESLint 独一无二, 是因为 ESLint 能够自定义运行时规则. 当你需要给你自己的项目或者公司制定某个规则, 但是有不需要发给 ESLint 官方的仓库的时候, 这个特性就很完美. 有了运行时规则, 你就不需要等下个版本的 ESLint 了, 或者因为你自己写的规则并不适合发表到大型 JavaScript 社区而感到沮丧, 只管写就是了, 然后在运行时里引入.</p>
<p>运行时规则写起来和其他格式并无二致. 写的时候就跟写其他规则一样, 写完了以后, 再执行下面这些步骤:</p>
<ol>
<li>把你的所有运行时规则都放到同一个目录下(比如, <code>eslint_rules</code>).</li>
<li>写一个<a href="https://eslint.org/docs/user-guide/configuring" target="_blank" rel="noopener">配置文件</a>, 在 <code>rules</code> 字段里, 表明你的规则 ID 以及对应的错误级别. 你的规则如果想要运行, 需要给 <code>1</code> 或者 <code>2</code> 作为值.</li>
<li>用<a href="https://eslint.org/docs/user-guide/command-line-interface" target="_blank" rel="noopener">命令行(CLI)</a>加上 <code>--rulesdir</code> 参数, 来指定你的运行时规则所在的文件夹.</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2018/04/18/ui-test-with-jest-and-puppeteer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/ui-test-with-jest-and-puppeteer/" itemprop="url">
                  教程：用 Jest 与 Puppeteer 进行 UI test
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2018-04-18 16:59:00" itemprop="dateCreated datePublished" datetime="2018-04-18T16:59:00+08:00">2018-04-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-04-19 04:11:44" itemprop="dateModified" datetime="2018-04-19T04:11:44+08:00">2018-04-19</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/translation-ui-test-jest-puppeteer-test/" itemprop="url" rel="index"><span itemprop="name">translation ui-test jest puppeteer test</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>原文地址：<a href="https://www.valentinog.com/blog/ui-testing-jest-puppetteer/#jest-puppeteer-visual-debug" target="_blank" rel="noopener">https://www.valentinog.com/blog/ui-testing-jest-puppetteer/#jest-puppeteer-visual-debug</a></p>
<p>原文作者： <a href="http://www.valentinog.com/" target="_blank" rel="noopener">Valentino Gagliardi</a></p>
</blockquote>
<p>自从 <strong>Puppeteer</strong> 这个库出现以来，我就开始考虑用 <strong>Jest 和 Puppeteer 进行测试</strong>了。 Puppeteer 有很多有意思的 API。</p>
<p><img src="https://www.valentinog.com/blog/wp-content/uploads/2017/10/testing-with-jest-puppeteer-wp.jpg" alt="Banner"></p>
<p>接下来的文章我将会以联系人表单为例，简单的讲解如何<strong>对其进行 UI Test</strong>。</p>
<p>测试的技术选型，我们会使用 Jest 和 Puppeteer。</p>
<p>昨天在写测试的时候，刚好看到了 Kent C.Dodds 写的文章。</p>
<p>“<a href="https://blog.kentcdodds.com/making-your-ui-tests-resilient-to-change-d37a6ee37269" target="_blank" rel="noopener">让 UI 测试脚本更耐用一些</a>”这篇文章里，阐述了怎么样通过使用 <code>data-*</code> 属性来让 UI 测试脚本更不容易失效。</p>
<p><code>data-*</code> 属性可以在几乎任何 HTML 元素上定义一个 data 属性。当需要利用 JavaScript 操作 HTML 进行数据交换的时候，这个属性特别有用。</p>
<p>Kent 的文章来的很是时候，因为当时我恰好也要写类似的东西了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.waitForSelector(<span class="string">"#contact-form"</span>);</span><br><span class="line"><span class="keyword">await</span> page.click(<span class="string">"#name"</span>);</span><br><span class="line"><span class="keyword">await</span> page.type(<span class="string">"#name"</span>, user.name);</span><br></pre></td></tr></table></figure>
<p>尽管我不太喜欢用自定义 <code>data-*</code> 这种方法来进行测试，但是不得不承认，这是一个好方法。不管你的程序是大型工程还是小型项目，这个方法都适用，但是在文章里，我还是用比较经典的元素选择的例子来写一下 demo。</p>
<p>号外，你对<a href="https://www.valentinog.com/blog/javascript-end-to-end-testing-cypress/" target="_blank" rel="noopener"><em>持续集成</em></a>感兴趣么？感兴趣的话可以看一下 Cypress &gt;&gt; <a href="https://www.valentinog.com/blog/javascript-end-to-end-testing-cypress/" target="_blank" rel="noopener"><em>用 Cypress 进行更好的 JavaScript E2E 测试</em></a>。</p>
<h2 id="用-Jest-与-Puppeteer-进行-UI-测试-测试一个联系人表单"><a href="#用-Jest-与-Puppeteer-进行-UI-测试-测试一个联系人表单" class="headerlink" title="用 Jest 与 Puppeteer 进行 UI 测试: 测试一个联系人表单"></a>用 Jest 与 Puppeteer 进行 UI 测试: 测试一个联系人表单</h2><p>我的目标是测试一个联系人表单。</p>
<p>如下：</p>
<p><img src="https://www.valentinog.com/blog/wp-content/uploads/2017/10/testing-with-jest-and-puppeteer-contact-form.png" alt="联系人表单"></p>
<p>它有如下元素：</p>
<ol>
<li>一个输入名字的 input</li>
<li>一个输入 email 的 input</li>
<li>一个输入手机号的 input</li>
<li>一个 textarea</li>
<li>一个隐私设置的 checkbox</li>
<li>一个提交 button</li>
</ol>
<p>如果我想测试这个联系人列表，我应该怎么做呢？</p>
<p><strong>测试</strong>上面这个表单，意味着要断言<strong>用户可以提交一个网络请求</strong>。</p>
<h2 id="用-Jest-与-Puppeteer-进行-UI-测试-安装工程"><a href="#用-Jest-与-Puppeteer-进行-UI-测试-安装工程" class="headerlink" title="用 Jest 与 Puppeteer 进行 UI 测试: 安装工程"></a>用 Jest 与 Puppeteer 进行 UI 测试: 安装工程</h2><p>我们先来小窥一下要用到的工具。</p>
<p><img src="https://www.valentinog.com/blog/wp-content/uploads/2017/10/puppeteer-logo.png" alt="puppeteer"></p>
<p><a href="https://facebook.github.io/jest/" target="_blank" rel="noopener"><strong>Jest</strong></a>: Facebook 开源的一个测试框架。Jest 通过一个基本的断言库(Except)提供了一个自动化测试的平台。</p>
<p><a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener"><strong>Puppeteer</strong></a>: 一个用来控制 headless Chrome 的 Node.js 库。虽然这个库还很新，但是现在正是试试这个库是适于加入你的工作流的好时候。</p>
<p><a href="https://www.npmjs.com/package/faker" target="_blank" rel="noopener"><strong>Faker</strong></a>: 一个用于产生随机数据的 Node.js 库。姓名、电话号码、地址。这个库很像 PHP 里的那个 Faker 库。</p>
<p>如果你已经弄好工程目录了，可以用下面的命令来安装上述的库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i jest puppeteer faker --save-dev</span><br></pre></td></tr></table></figure></p>
<p>因为 Puppeteer 需要下载它自己所需要的版本的 Chromium，所以安装 Puppeteer 会花一些时间。</p>
<p>Chromium 是一个在 Chrome 之后的开源浏览器。Chromium 和 Chrome 几乎共享了所有的功能，两者的差异只在部分协议的细节上。</p>
<p>一旦安装完成了，你需要在 <code>package.json</code> 里配置一下 Jest。<code>test</code> 命令应该写成一个可执行的 Jest 命令：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "test": "jest"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Jest 脚本里，别忘了引入 Puppeteer：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> puppeteer <span class="keyword">from</span> <span class="string">"puppeteer"</span>;</span><br></pre></td></tr></table></figure></p>
<p>为了能用 ES6 的语法，我们需要为 Jest 配置 Babel。用下面这个命令安装跟 Babel 相关的东西：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-core babel-jest babel-preset-env --save-dev</span><br></pre></td></tr></table></figure></p>
<p>安装完以后，在你的工程目录里创建一个文件名为 <code>.babelrc</code> 的文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述这些都配置好后，我们就可以开始写一个简单的测试脚本了。</p>
<h2 id="用-Jest-与-Puppeteer-进行-UI-测试-写测试脚本"><a href="#用-Jest-与-Puppeteer-进行-UI-测试-写测试脚本" class="headerlink" title="用 Jest 与 Puppeteer 进行 UI 测试: 写测试脚本"></a>用 Jest 与 Puppeteer 进行 UI 测试: 写测试脚本</h2><p>在你的工程目录下新建一个文件夹，可以命名为 <code>test</code> 或者 <code>spec</code>。然后在这个文件夹里建一个新的文件，名字是 <code>form.spec.js</code>。</p>
<p>接下来我会把测试脚本拆成好几部分，把重点拿出来让你看看。在文章的末尾，我们能看到完整的代码。</p>
<p>按照顺序引入 Fake 和 Puppeteer:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> faker <span class="keyword">from</span> <span class="string">"faker"</span>;</span><br><span class="line"><span class="keyword">import</span> puppeteer <span class="keyword">from</span> <span class="string">"puppeteer"</span>;</span><br></pre></td></tr></table></figure></p>
<p>配置表单的 URL(也许你想测试的是本地启动服务的开发版本，而不是真实的网站的生产版本)：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> APP = <span class="string">"https://www.change-this-to-your-website.com/contact-form.html"</span>;</span><br></pre></td></tr></table></figure></p>
<p>用 Faker 创建一个假的用户信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> lead = &#123;</span><br><span class="line">  name: faker.name.firstName(),</span><br><span class="line">  email: faker.internet.email(),</span><br><span class="line">  phone: faker.phone.phoneNumber(),</span><br><span class="line">  message: faker.random.words()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>给 Puppeteer 定义一些变量：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> page;</span><br><span class="line"><span class="keyword">let</span> browser;</span><br><span class="line"><span class="keyword">const</span> width = <span class="number">1920</span>;</span><br><span class="line"><span class="keyword">const</span> height = <span class="number">1080</span>;</span><br></pre></td></tr></table></figure></p>
<p>定义 Puppeteer 应该表现出怎么样的行为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">beforeAll(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    headless: <span class="literal">false</span>,</span><br><span class="line">    slowMo: <span class="number">80</span>,</span><br><span class="line">    args: [<span class="string">`--window-size=<span class="subst">$&#123;width&#125;</span>,<span class="subst">$&#123;height&#125;</span>`</span>]</span><br><span class="line">  &#125;);</span><br><span class="line">  page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.setViewport(&#123; width, height &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">afterAll(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  browser.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>beforeAll</code> 和 <code>afterAll</code> 都是 Jest 方法。简单来说就是，在开始跑测试以前，我们必须用 Puppeteer 启动一个浏览器核心，然后用 <code>browser.newPage()</code> 启动打开一个新的页面。</p>
<p>当测试用例完成了以后，浏览器核心必须通过 <code>browser.close()</code> 来进行关闭。</p>
<p>除了 <code>beforeAll</code> 和 <code>afterAll</code> 以外，Jest 还有很多其他 API，详情可以看一下 <a href="https://facebook.github.io/jest/docs/en/api.html" target="_blank" rel="noopener">Jest 文档</a>。毕竟，整个测试只用一个浏览器来核心完成要比每个测试用例都重新启动和关闭浏览器核心要方便的多。</p>
<p>上面的代码里有一些需要注意的地方：</p>
<p>我在代码里用了 <code>headless: false</code> 来启动(lanuch)浏览器核心，以便把 Chromuim 真实的显示出来。这其实只是因为我需要录像来给你展示测试是如何工作的而已，并不是测试必须这样写。</p>
<p>在实际测试过程中，并不需要打开一个实际的浏览器页面，所以到时候，只需要把跟 <code>lanuch</code> 方法相关的代码删除掉就可以了。</p>
<p><code>setViewPort()</code> 也同样，可以删掉了。你也可以设置根据不同的环境来进行不同的 <code>lanuch</code> 操作，比如在开发环境中禁用 <code>headless</code> 模式以便<a href="./ui-test-with-jest-and-puppeteer.html#bonus">可视化调试</a>，在跑测试的时候只启动核心而不显示窗口。<a href="./ui-test-with-jest-and-puppeteer.html#bonus">点这里去了解一下怎么做</a>。</p>
<p>现在我们可以写实际的测试脚本了：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Contact form"</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">"lead can submit a contact request"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> page.goto(APP);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">"[data-test=contact-form]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"input[name=name]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">"input[name=name]"</span>, lead.name);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"input[name=email]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">"input[name=email]"</span>, lead.email);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"input[name=tel]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">"input[name=tel]"</span>, lead.phone);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"textarea[name=message]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.type(<span class="string">"textarea[name=message]"</span>, lead.message);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"input[type=checkbox]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.click(<span class="string">"button[type=submit]"</span>);</span><br><span class="line">    <span class="keyword">await</span> page.waitForSelector(<span class="string">".modal"</span>);</span><br><span class="line">  &#125;, <span class="number">16000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意，上面的代码里在 <a href="https://www.valentinog.com/blog/testing-api-koa-jest/" target="_blank" rel="noopener">Jest 里使用 async/await</a> 了。即假设你在用最新版本的 Node.js 了。</p>
<p>我们来看看当使用 Jest 和 Puppeteer 的时候，headless Chrome 都做了些什么：</p>
<ol>
<li>打开 APP 里写的那个链接；</li>
<li>等待联系人列表的 UI 渲染；</li>
<li>点击、填入表单项；</li>
<li>点击 checkbox；</li>
<li>提交表单；</li>
<li>等待 <code>.modal</code> 这个 DOM 元素出现。</li>
</ol>
<p>注意：注意以第二参数形式在 <code>test()</code> 方法里传递给 Jasmine 的超时时间（16000）。当你像看 Chrome 浏览器跟页面的交互的时候，这个设置是很有必要的。</p>
<p>如果不是 headless 模式，并且没有配置超时时间的话，会得到如下的错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL</span><br></pre></td></tr></table></figure></p>
<p>总之，当 Chrome 运行在 headless 模式的时候，的确可以移除超时设置的，只是会报错。</p>
<p>然后用下面的命令来执行测试：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以看见下面这样的魔法了：</p>
<iframe width="740" height="416" src="https://www.youtube.com/embed/qYo-NL2qFPM" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>

<h2 id="用-Jest-与-Puppeteer-进行测试：测试更多的部分"><a href="#用-Jest-与-Puppeteer-进行测试：测试更多的部分" class="headerlink" title="用 Jest 与 Puppeteer 进行测试：测试更多的部分"></a>用 Jest 与 Puppeteer 进行测试：测试更多的部分</h2><p>ok，现在联系人表单已经测试好了，我可以继续测试这个页面里其他部分的内容了。</p>
<p>每个网页，应该都有一个<strong>有意义</strong>的标题对吧，那么怎么测试呢？</p>
<p>下面的代码是用来测试 <code>&lt;title&gt;&lt;/title&gt;</code> 是否正确的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Testing the frontend"</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">"assert that &lt;title&gt; is correct"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> title = <span class="keyword">await</span> page.title();</span><br><span class="line">    expect(title).toBe(</span><br><span class="line">      <span class="string">"Gestione Server Dedicati | Full Managed | Assistenza Sistemistica"</span></span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 在下面你可以添加更多的测试用例！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>导航栏呢？页面里至少应该有一个导航栏吧！</p>
<p>用 Jest 与 Puppeteer 测试导航栏是否存在：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  test(<span class="string">"assert that a div named navbar exists"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> navbar = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">".navbar"</span>, el =&gt; (el ? <span class="literal">true</span> : <span class="literal">false</span>));</span><br><span class="line">    expect(navbar).toBe(<span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<p>或者测试一下，某个特定的元素里是否有期望的文本信息：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line">  test(<span class="string">"assert that main title contains the correct text"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> mainTitleText = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">"[data-test=main-title]"</span>, el =&gt; el.textContent);</span><br><span class="line">    expect(mainTitleText).toEqual(<span class="string">"GESTIONE SERVER, Full Managed"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<p>那么有关 SEO 应该怎么测试呢？</p>
<p>用 Jest 与 Puppeteer 测试一下 <strong>SEO</strong> 关注的重点，比如一个友情链接是否存在：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"SEO"</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">"canonical must be present"</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> page.goto(<span class="string">`<span class="subst">$&#123;APP&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">const</span> canonical = <span class="keyword">await</span> page.$<span class="built_in">eval</span>(<span class="string">"link[rel=canonical]"</span>, el =&gt; el.href);</span><br><span class="line">    expect(canonical).toEqual(<span class="string">"https://www.servermanaged.it/"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当然，还可以测试更多的内容。</p>
<p>在那天写完 UI 测试后，看见那些绿色的标记，我很开心：<br><img src="https://www.valentinog.com/blog/wp-content/uploads/2017/10/testing-with-jest-and-puppeteer-test-suite.png" alt="测试用例通过情况"></p>
<p><strong>Puppeteer</strong> 给了你无限的可能。现在有很多新的测试框架正在基于 Puppeteer 进行开发。当然，API 还会继续改善，但是要知道，基础条件是必不可少的。</p>
<p>并且 Puppeteer 还能和 Jest 很好的结合在一起。</p>
<h2 id="用-Jest-与-Puppeteer-进行测试：下一步"><a href="#用-Jest-与-Puppeteer-进行测试：下一步" class="headerlink" title="用 Jest 与 Puppeteer 进行测试：下一步"></a>用 Jest 与 Puppeteer 进行测试：下一步</h2><p>可能你会觉得 Puppeteer 本身或者 Puppeteer 的 API 并不够方便。我也懂你的感受。</p>
<p>这个库还很新，但是现在是检验这个库是否适合融入你的工作流的好时候。</p>
<p>Puppeteer 仍然在开发阶段中，并且接下来会有很多的改善。与此同时，你可以看看那些用了 <a href="https://www.cypress.io/" target="_blank" rel="noopener">Cypress</a> 的例子。</p>
<p>你是怎么样测试你的程序的呢？有很多人在用 <a href="https://ropig.com/blog/end-end-tests-dont-suck-puppeteer/" target="_blank" rel="noopener">Puppeteer 做 E2E 测试</a>。你呢？</p>
<p><br id="bonus"></p>
<h2 id="附录：用-Jest-与-Puppeteer-进行测试时的可视化-debug"><a href="#附录：用-Jest-与-Puppeteer-进行测试时的可视化-debug" class="headerlink" title="附录：用 Jest 与 Puppeteer 进行测试时的可视化 debug"></a>附录：用 Jest 与 Puppeteer 进行测试时的可视化 debug</h2><p>Puppeteer 在使用的时候，你可以选择 Chromium 的 <strong>headless</strong> 和 <strong>非 headless</strong> 两种模式。</p>
<p>就像我们之前看到的那样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">beforeAll(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">      <span class="comment">// Debug mode !</span></span><br><span class="line">      headless: <span class="literal">false</span>,</span><br><span class="line">      slowMo: <span class="number">80</span>,</span><br><span class="line">      args: [<span class="string">`--window-size=1920,1080`</span>]</span><br><span class="line">    &#125;);</span><br><span class="line">  page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果你想进行可视化的 debug，那就必须要给 Jasmine 设置一个超时时间用来启动浏览器核心。否则测试会很快的中止掉，因为异步请求全部被忽略掉了。这个超时时间被定义为 <code>test()</code> 函数的第二个参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">"Contact form"</span>, () =&gt; &#123;</span><br><span class="line">  test(</span><br><span class="line">    <span class="string">"lead can submit a contact request"</span>,</span><br><span class="line">    <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">///// some assertions</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="number">16000</span> <span class="comment">// &lt;&lt;&lt; Jasmine timeout</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>但是当在自动化测试环境的时候，就不需要<strong>真的启动浏览器窗口</strong>了。如果你启动了，这将会导致这个测试永远的持续下去。所以怎么样<strong>在 headless 模式和普通模式之间轻松的进行切换</strong>呢？</p>
<p>写点辅助函数，把这些函数放在文件 <code>testingInit.js</code> 里：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> isDebugging = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> debugging_mode = &#123;</span><br><span class="line">    puppeteer: &#123;</span><br><span class="line">      headless: <span class="literal">false</span>,</span><br><span class="line">      slowMo: <span class="number">80</span>,</span><br><span class="line">      args: [<span class="string">`--window-size=1920,1080`</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    jasmine: <span class="number">16000</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> process.env.NODE_ENV === <span class="string">"debug"</span> ? debugging_mode : <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以在你的测试脚本里引用这个辅助函数了：<br>先是<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///</span></span><br><span class="line"><span class="keyword">import</span> &#123; isDebugging &#125; <span class="keyword">from</span> <span class="string">"./testingInit.js"</span>;</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">beforeAll(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  browser = <span class="keyword">await</span> puppeteer.launch(isDebugging().puppeteer)); <span class="comment">// &lt;&lt;&lt; 可视化模式</span></span><br><span class="line">  page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line"><span class="comment">///</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 一些脚本</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">"Contact form"</span>, () =&gt; &#123;</span><br><span class="line">  test(</span><br><span class="line">    <span class="string">"lead can submit a contact request"</span>,</span><br><span class="line">    <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">///// 一些断言</span></span><br><span class="line">    &#125;, isDebugging().jasmine <span class="comment">// &lt;&lt;&lt; Jasmine timeout</span></span><br><span class="line">  );</span><br></pre></td></tr></table></figure></p>
<p>然后你就可以用命令分别用这两种模式来启动了，如果你想用 headless 模式启动的话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm test</span><br></pre></td></tr></table></figure></p>
<p>下面是如何用 debug 模式启动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_ENV=debug npm test</span><br></pre></td></tr></table></figure></p>
<p>感谢阅读！</p>
<p>图片来源：<a href="https://unsplash.com/@shotbyjames" target="_blank" rel="noopener">https://unsplash.com/@shotbyjames</a></p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/08/14/this-in-react-with-es6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/14/this-in-react-with-es6/" itemprop="url">
                  [译]React 与 ES6 - 第三部分，为 React 类绑定方法(ES7 同理)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-08-14 01:58:00 / Modified: 01:59:16" itemprop="dateCreated datePublished" datetime="2017-08-14T01:58:00+08:00">2017-08-14</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/React-Performance-Anti-pattern/" itemprop="url" rel="index"><span itemprop="name">React Performance Anti-pattern</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>React 与 ES6 - 第三部分，为 React 类绑定方法(ES7 同理)<br>=</p>
<p>这篇文章，是我们探索在 ECMAScript6 和 ECMAScript7 中 React 的使用方法的系列文章的第三篇。</p>
<p>想看这个系列的其他文章，请点如下链接：</p>
<ul>
<li><a href="http://egorsmirnov.me/2015/05/22/react-and-es6-part1.html" target="_blank" rel="noopener">React and ES6 - Part 1, Introduction into ES6 and React</a></li>
<li><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html" target="_blank" rel="noopener">React and ES6 - Part 2, React Classes and ES7 Property Initializers</a></li>
<li>React and ES6 - Part 3, Binding to methods of React class (ES7 included)</li>
<li><a href="http://egorsmirnov.me/2015/09/30/react-and-es6-part4.html" target="_blank" rel="noopener">React and ES6 - Part 4, React Mixins when using ES6 and React</a></li>
<li><a href="http://egorsmirnov.me/2015/10/11/react-and-es6-part5.html" target="_blank" rel="noopener">React and ES6 - Part 5, React and ES6 Workflow with JSPM</a></li>
<li><a href="http://egorsmirnov.me/2016/04/11/react-and-es6-part6.html" target="_blank" rel="noopener">React and ES6 - Part 6, React and ES6 Workflow with Webpack</a></li>
</ul>
<table>
<thead>
<tr>
<th>React</th>
<th>JavaScript</th>
</tr>
</thead>
<tbody>
<tr>
<td><img src="http://egorsmirnov.me/images/posts/react.png" alt="React"></td>
<td><img src="http://egorsmirnov.me/images/posts/js.png" alt="ECMAScript"></td>
</tr>
</tbody>
</table>
<blockquote>
<p>这个文章中的相关代码片段，也可以在 <a href="https://github.com/egor-smirnov/egorsmirnov.me-examples/tree/master/react-and-es6-part-3" target="_blank" rel="noopener">GitHub</a> 中找到</p>
</blockquote>
<blockquote>
<p>最后更新日期: 2016年6月18日，更新内容包含了 React15 以及 Babel6。</p>
</blockquote>
<p><a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html#cartitem-render-method" target="_blank" rel="noopener">这个系列的旧文章</a>里，有一篇讲到了“CartItem 渲染方法”，如果你看过的话，可能会对 <code>{this.increaseQty.bind(this)}</code> 这种写法有点疑惑。</p>
<p>如果我们在 ES6 的代码里，对同样的 demo 用 <code>{this.increaseQty}</code> 来绑定一个组件的事件处理函数，浏览器会报 <code>Uncaught TypeError: Cannot read property &#39;setState&#39; of undefined</code> 错误：</p>
<p><img src="http://egorsmirnov.me/images/posts/2015-08-16/console.png" alt="在 ES6 中用老的写法，会报 Uncahught TypeError"></p>
<p>这是因为在 ES6 中，函数的 <code>this</code> 绑定规则已经发生了变化，我们在调用 <code>this</code> 的时候，调用的并不是类本身，而是 <code>undefined</code>。但是如果你在写 React 的时候用的是 <code>React.createClass()</code> 这种方法， React 会自动把所有类的方法的 <code>this</code> 绑定到对应的实例上。</p>
<p>在 React 组件开始支持用 ES6 <code>class</code> 来实现的时候，React 小组决定不再支持自动绑定。详细的原因，可以看<a href="http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#autobinding" target="_blank" rel="noopener">这篇文章</a>。</p>
<p>下面来看看在用 ES6 <code>class</code> 写 JSX 文件的时候，怎么给类的方法绑定 <code>this</code> 值。</p>
<h2 id="1-用-Function-prototype-bind"><a href="#1-用-Function-prototype-bind" class="headerlink" title="1. 用 Function.prototype.bind()"></a>1. 用 Function.prototype.bind()</h2><p>如下：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increaseQty.bind(<span class="keyword">this</span>)&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于 ES6 中类的方法本质上是 JavaScript 函数，因此继承了来自于 Function 原型上的 <code>bind()</code> 方法。现在，再调用 JSX 里的 <code>increaseQty()</code> 方法的时候，<code>this</code> 就会指向类的实例。如果对 Function.prototype.bind() 有疑惑，可以看这篇<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind" target="_blank" rel="noopener"> MDN 文章</a>。</p>
<h2 id="2-在构造函数中进行绑定"><a href="#2-在构造函数中进行绑定" class="headerlink" title="2. 在构造函数中进行绑定"></a>2. 在构造函数中进行绑定</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.increaseQty = <span class="keyword">this</span>.increaseQty.bind(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increaseQty&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就不需要在 JSX 里用 <code>bind()</code> 方法了，但是增加了构造函数里的代码。</p>
<h1 id="3-用箭头函数以及构造函数"><a href="#3-用箭头函数以及构造函数" class="headerlink" title="3. 用箭头函数以及构造函数"></a>3. 用箭头函数以及构造函数</h1><p>在 <a href="https://babeljs.io/docs/learn-es2015/#arrows" target="_blank" rel="noopener">ES6 的箭头函数</a> 被调用的时候，<code>this</code> 是函数执行的上下文。我们可以利用这个特性，在构造函数里重新定义 <code>increaseQty()</code>：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>._increaseQty = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.increaseQty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;_this.increaseQty&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>(译注：是不是写错了)</p>
<h1 id="4-用箭头函数以及-ES2015-的类属性"><a href="#4-用箭头函数以及-ES2015-的类属性" class="headerlink" title="4. 用箭头函数以及 ES2015+ 的类属性"></a>4. 用箭头函数以及 ES2015+ 的类属性</h1><p>除了上面提到的 3 种方法，还可以把箭头函数跟 ES2015+ 的类属性组合起来写：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    increaseQty = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.increaseQty();</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increaseQty&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>哈哈，这次我们没有用长的构造函数代码来实现我们的需求了，而是巧妙的利用了类的属性初始化。</p>
<p><strong>警告：</strong> 类属性现在还不是当前的 JavaScript 标准，但是可以用 Babel 的实验版本标记(也就是 stage 0)来解决这个问题。关于 Babel 的使用方法，可以查看 <a href="https://babeljs.io/docs/usage/experimental/" target="_blank" rel="noopener"><code>Babel</code> 文档</a>。<br>这个系列的文章 <a href="http://egorsmirnov.me/2015/06/14/react-and-es6-part2.html" target="_blank" rel="noopener">React and ES6 - Part 2, React Classes and ES7 Property Initializers</a> 里就已经在用 stage 0 了，所以在这篇文章里，应该不是什么问题。</p>
<h1 id="5-用-ES2015-的函数绑定语法"><a href="#5-用-ES2015-的函数绑定语法" class="headerlink" title="5. 用 ES2015+ 的函数绑定语法"></a>5. 用 ES2015+ 的函数绑定语法</h1><p>最近 Babel 增加了一个语法糖，用 <code>::</code> 来表示 <code>Function.prototype.bind()</code>，这个内容的细节不再展开。当然，如果你想了解细节，有些人已经在 <a href="http://babeljs.io/blog/2015/05/14/function-bind/" target="_blank" rel="noopener">Babel 官方文章</a> 里对这个作了很好的解释。</p>
<p>下面是用了 ES2015+ 绑定语法的代码：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.increaseQty = ::<span class="keyword">this</span>.increaseQty;</span><br><span class="line">        <span class="comment">// line above is an equivalent to this.increaseQty = this.increaseQty.bind(this);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;<span class="keyword">this</span>.increaseQty&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>友情提示，这是一个实验特性，如果想用的话，先考虑一下风险问题。</p>
<h1 id="6-直接在-JSX-里用-ES2015-的函数绑定语法"><a href="#6-直接在-JSX-里用-ES2015-的函数绑定语法" class="headerlink" title="6. 直接在 JSX 里用 ES2015+ 的函数绑定语法"></a>6. 直接在 JSX 里用 ES2015+ 的函数绑定语法</h1><p>直接在 JSX 里用 ES2015+ 的语法糖，就不用再写构造函数的代码了：<br><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">CartItem</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        &lt;button onClick=&#123;::<span class="keyword">this</span>.increaseQty&#125; className=<span class="string">"button success"</span>&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>看看，代码写起来很简洁，但是，这样会导致每次子组件被渲染的时候，重新初始化一个函数(译注：有关这个问题的扩展阅读<a href="http://olafcheng.github.io/react/performance/anti-pattern/2017/08/12/react-performance-anti-pattern.html">请看这里</a>)，所以性能上是存在问题的。如果你想用纯渲染函数(或者 ES2016 的类)的时候，这样写会导致更严重的问题。</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>这篇文章里我们写了若干种给 React 组件的类的方法绑定 <code>this</code> 值的方式。这些代码我已经在第二部分的基础上写了一些<a href="https://github.com/egor-smirnov/egorsmirnov.me-examples/tree/master/react-and-es6-part-3" target="_blank" rel="noopener">测试用例</a>。</p>
<p>在下篇文章中，我们要讲的是用 ES2015 写 React 的时候，有关 state 的问题。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/03/12/road-of-read-source-code-of-vue-step-0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/12/road-of-read-source-code-of-vue-step-0/" itemprop="url">
                  实现一个 MVVM 中的 Observer (step 0)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-03-12 16:27:00 / Modified: 18:52:13" itemprop="dateCreated datePublished" datetime="2017-03-12T16:27:00+08:00">2017-03-12</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript-MVVM-vue/" itemprop="url" rel="index"><span itemprop="name">javascript MVVM vue</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>假设存在如下需求:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> app1 = <span class="keyword">new</span> Observer(&#123;</span><br><span class="line">  name: <span class="string">'youngwind'</span>,</span><br><span class="line">  age: <span class="number">25</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app2 = <span class="keyword">new</span> Observer(&#123;</span><br><span class="line">  university: <span class="string">'bupt'</span>,</span><br><span class="line">  major: <span class="string">'computer'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要实现的结果如下：</span></span><br><span class="line">app1.data.name <span class="comment">// 你访问了 name</span></span><br><span class="line">app1.data.age = <span class="number">100</span>;  <span class="comment">// 你设置了 age，新的值为100</span></span><br><span class="line">app2.data.university <span class="comment">// 你访问了 university</span></span><br><span class="line">app2.data.major = <span class="string">'science'</span>  <span class="comment">// 你设置了 major，新的值为 science</span></span><br></pre></td></tr></table></figure></p>
<p>这个功能的实现, 要用到 <code>Object</code> 中 <code>setter</code> 和 <code>getter</code> 的劫持。<br>结合着看过的对 <em>Vue</em> 的源码分析和自己理解的部分, 写一段简单的代码，功能并不完善。</p>
<p>一共分为 5 步来实现, 这里只实现第 1 步, 最简单的原理解释。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = data;</span><br><span class="line">    <span class="keyword">this</span>.bind(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bind (data) &#123;</span><br><span class="line">    <span class="comment">// 这里通过私有属性构成一个内部才能访问的闭包</span></span><br><span class="line">    <span class="keyword">let</span> storage = <span class="keyword">new</span> DataStorage();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 1. 在初始化的时候, 把数据存进对象自己的 DataStorage 实例中</span></span><br><span class="line">      <span class="comment">// 2. 然后通过 setter 和 getter 可以对 DataStorage 进行操作</span></span><br><span class="line">      storage.addProp(data, key); <span class="comment">// 存入数据</span></span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        configurable: <span class="literal">false</span>,</span><br><span class="line">        set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val === storage.getProp(key)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'你设置了 '</span> + key + <span class="string">', 但是没有对值进行更改。'</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            storage.setProp(key, val);</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'你设置了 '</span> + key + <span class="string">', 新的值为 '</span> + val);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'你访问了 '</span> + key + <span class="string">', 值为 '</span> + storage.getProp(key));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于对每个类生成实例, 分别存储每个类的数据</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStorage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (obj) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addProp (data, key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data[key] = data[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getProp (key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.data[key];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setProp (key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data[key] = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用题目要求的数据进行测试, 测试结果如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">你访问了 name, 值为 youngwind</span><br><span class="line">你设置了 age, 新的值为 <span class="number">100</span></span><br><span class="line">你访问了 university, 值为 bupt</span><br><span class="line">你设置了 major, 新的值为 science</span><br></pre></td></tr></table></figure></p>
<p>示例可以点击<a href="!--￼3--&gt;/demos/ife2017/vue/step-0/index.html">这里</a>进行查看。</p>
<p>程序很简单, 比较有意思的是作用域这一部分, 猜猜看, <code>bind()</code> 原型方法中会不会形成闭包?</p>
<p>答案: 会，因为 <code>bind()</code> 在执行的时候, 内部变量 <code>Object.defineProperty</code> 中定义的两个<strong>匿名函数</strong>被全局变量 <code>app1</code> 的 <code>getter</code> 和 <code>setter</code> 给分别引用了。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/03/02/translation_why_are_there_no_justify_self_and_justify_items/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/02/translation_why_are_there_no_justify_self_and_justify_items/" itemprop="url">
                  [译]在 CSS3 flex 布局中, 为什么没有 justify-self 和 justify-items 属性?
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-03-02 21:07:00 / Modified: 23:17:27" itemprop="dateCreated datePublished" datetime="2017-03-02T21:07:00+08:00">2017-03-02</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/CSS-flex-layout-margin-translation/" itemprop="url" rel="index"><span itemprop="name">CSS flex layout margin translation</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="在-CSS3-flex-布局中-为什么没有justify-self-和-justify-items-属性"><a href="#在-CSS3-flex-布局中-为什么没有justify-self-和-justify-items-属性" class="headerlink" title="在 CSS3 flex 布局中, 为什么没有justify-self 和 justify-items 属性?"></a>在 <code>CSS3</code> <code>flex</code> 布局中, 为什么没有<code>justify-self</code> 和 <code>justify-items</code> 属性?</h2><p>译自: <a href="http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties" target="_blank" rel="noopener">http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties</a></p>
<p><strong><code>flex</code> 容器内,主轴上元素的排列方法, 是如下定义的:</strong></p>
<blockquote>
<p>To align flex items along the main axis there is one property: justify-content</p>
<p>To align flex items along the cross axis there are three properties: align-content, align-items and align-self.</p>
</blockquote>
<p>译文:</p>
<blockquote>
<p>为了排列主轴上的 <code>flex</code> 元素, 我们有这样的一个属性: <code>justify-content</code></p>
<p>而为了排列交叉轴上的 <code>flex</code> 元素, 我们却有三个属性: <code>align-content</code>, <code>align-items</code> 还有 <code>align-self</code>.</p>
</blockquote>
<p>于是问题就出现了:</p>
<blockquote>
<p> 为什么在  <code>CSS3 flex</code> 布局中, 没有<code>justify-self</code> 和 <code>justify-items</code> 属性?</p>
</blockquote>
<p>可以这样回答: 这两个额外的属性, 没有进行规范的必要。</p>
<p><a href="http://www.w3.org/TR/css-flexbox-1/" target="_blank" rel="noopener"><code>flexbox</code> 的规范</a>指出了两种排列主轴 <code>flex</code> 元素的方法:</p>
<ol>
<li><code>justify-content</code> 属性, 还有</li>
<li><a href="https://www.w3.org/TR/css-flexbox-1/#auto-margins" target="_blank" rel="noopener"><code>auto margins</code></a></li>
</ol>
<hr>
<h3 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h3><p><a href="http://www.w3.org/TR/css-flexbox-1/#justify-content-property" target="_blank" rel="noopener">justify-content</a> 属性用来排布 <code>flex</code> 容器中, 主轴上的元素。</p>
<p>这个元素作用在 <code>flex</code> 的容器元素上, 但是会对所有 <code>flex</code> 容器里的子元素产生影响。</p>
<p>下面是 5 种排列的选项:</p>
<ul>
<li><code>flex-start</code> ~ 元素靠近一行的开头</li>
</ul>
<p><img src="https://i.stack.imgur.com/YOzeU.png" alt="flex-start"></p>
<ul>
<li><code>flex-end</code> ~ 元素靠近一行的末尾</li>
</ul>
<p><img src="https://i.stack.imgur.com/13Z1u.png" alt="flex-end"></p>
<ul>
<li><code>center</code> ~ 元素靠近一行的中间</li>
</ul>
<p><img src="https://i.stack.imgur.com/oKi7M.png" alt="center"></p>
<ul>
<li><code>space-between</code> ~ 元素被均匀的分散开, 其中, 第一个元素位于一行的开头, 而最后一个元素位于一行的末尾. 而一行的开头和末尾, 则由 <a href="http://www.w3.org/TR/css-flexbox-1/#flex-direction-property" target="_blank" rel="noopener"><code>flex-direction</code></a> 还有 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/direction" target="_blank" rel="noopener"><code>writting mode</code></a>(<code>ltr</code> 或者 <code>rtl</code>)来决定。</li>
</ul>
<p><img src="https://i.stack.imgur.com/0mQqd.png" alt="space-between"></p>
<ul>
<li><code>space-around</code> ~ 除了每个元素的开头和结尾都有一半的间隔以外, 和 <code>space-between</code> 是一样的。</li>
</ul>
<p><img src="https://i.stack.imgur.com/u4BH6.png" alt="space-around"></p>
<h3 id="自动外边距-Auto-Margins"><a href="#自动外边距-Auto-Margins" class="headerlink" title="自动外边距 (Auto Margins)"></a>自动外边距 (Auto Margins)</h3><p><a href="http://www.w3.org/TR/css-flexbox-1/#auto-margins" target="_blank" rel="noopener"><code>auto</code> margin</a>(恰当的利用外边距的 <code>auto</code> 属性) 可以让元素居中排列、均匀分散或者是分组排列。</p>
<p><code>auto</code> margin 是作用在 <code>flex</code> 容器的子元素本身上的, 不像 <code>justify-content</code> 属性是作用在父级容器上的。</p>
<h3 id="将一组子元素靠右排列-而将第一个子元素单独靠左排列"><a href="#将一组子元素靠右排列-而将第一个子元素单独靠左排列" class="headerlink" title="将一组子元素靠右排列, 而将第一个子元素单独靠左排列"></a>将一组子元素靠右排列, 而将第一个子元素单独靠左排列</h3><p><strong>问题发生的情景</strong>:</p>
<blockquote>
<p>让一组 <code>flex</code> 元素靠右排列(<code>justify-content: flex-end</code>), 而其中的第一个元素, 靠左排列(<code>justify-self: flex-start</code>)</p>
<p><em>想象一下一个带有 logo 的导航条。如果有了 <code>justify-content</code> 和 <code>justify-self</code> 属性, 那么这个导航条就可以完美的用 <code>flex</code> 布局来实现, 从而如丝般顺滑的自适应各种尺寸的屏幕(译注: 由于大量 ie8/6 的存在, 国内现状并不是这样)。</em></p>
</blockquote>
<p><img src="https://i.stack.imgur.com/D3Vnv.png" alt="flexes-0"><br><img src="https://i.stack.imgur.com/Um8DM.png" alt="flexes-1"></p>
<p><strong>其他的可能会用到的场景:</strong><br><img src="https://i.stack.imgur.com/qLzgU.png" alt="flexes-2"><br><img src="https://i.stack.imgur.com/HtaOc.png" alt="flexes-3"><br><img src="https://i.stack.imgur.com/M2WkZ.png" alt="flexes-4"></p>
<hr>
<p>把一个 <code>flex</code> 元素放到 <code>flex</code> 容器的一角:<br>比如下面的场景:</p>
<blockquote>
<p>把一个 <code>flex</code> 元素放到 <code>flex</code> 容器的一角  .box { align-self: flex-end; justify-self: flex-end; }</p>
</blockquote>
<p><img src="https://i.stack.imgur.com/BtbfK.png" alt="flexes-5"></p>
<hr>
<p><strong>水平垂直居中一个 <code>flex</code> 元素</strong><br><img src="https://i.stack.imgur.com/lV9a0.png" alt="flexes-6"></p>
<p><code>margin: auto;</code> 可以用来替代 <code>justify-content: center; align-items: center;</code>, 就像下面这样：</p>
<p>从<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>换成<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box56</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或许你会问, 这两个有什么区别呢？当你想<a href="http://stackoverflow.com/q/33454533/3597276" target="_blank" rel="noopener">水平垂直居中一个大小超过 <code>flex</code> 容器 的 <code>flex</code> 元素</a>时, 就会知道了。</p>
<hr>
<p><strong>居中一个 <code>flex</code> 元素, 然后在第一个 <code>flex</code> 元素和底边缘的中间再放置一个水平居中的 <code>flex</code> 元素</strong></p>
<p><code>flex</code> 容器内元素的排列是通过分配剩余的空间来实现的。</p>
<p>因此，为了在一个独立元素的旁边, 再居中放置一个元素, 必须对某些属性进行抵销。</p>
<p>In the examples below, invisible third flex items (boxes 61 &amp; 68) are introduced to balance out the “real” items (box 63 &amp; 66).</p>
<p>在下面的例子中, 不可见的第三个 <code>flex</code> 元素(boxes 61 和 68), 被用来实现居中布局, 以便让显示出来的元素(boxes 63 和 66)符合居中要求。</p>
<p><img src="https://i.stack.imgur.com/3IeTy.png" alt="flexes-7"><br><img src="https://i.stack.imgur.com/BmtRt.png" alt="flexes-8"></p>
<p>不过，这种布局方法在语义上并无可取之处。</p>
<p>我们也可以用伪元素来替代真实的 DOM 元素。也可以用绝对定位来实现这个要求，参见<a href="http://stackoverflow.com/q/36191516/3597276" target="_blank" rel="noopener">flexbox 中的绝对定位</a> 中介绍的三种办法。</p>
<p><em>注意: 上面的例子只适用于部分居中的要求 ———— 如果容器元素是等宽等高的(when the outermost items are equal height/width)或者 <code>flex</code> 容器的子元素是不同长度的，再看看接下来的例子。</em></p>
<p><strong>当相邻的元素尺寸不相同时，如何居中 <code>flex</code> 元素</strong></p>
<p>看下面的案例要求：</p>
<blockquote>
<p>在某一行上有三个元素，想实现第二个元素居中显示(<code>justify-content: center</code>)，而第一个和第三个分别靠左(<code>justify-self: flex-start</code>)和靠右显示(<code>justify-self: flex-end</code>)。</p>
<p><strong>注意</strong>: <code>space-around</code> 和 <code>space-between</code> 在这里是无法达到想要的那种效果的，因为需要进行均匀排列的元素本身的宽度是不一样的(<a href="http://jsfiddle.net/7an37m20/12/" target="_blank" rel="noopener">看这个例子</a>)。</p>
</blockquote>
<p>正如上面提到的注意事项所说，在 DOM 结构上处于中间的那个元素，只有在相邻的元素等高或者等宽(取决于 <code>flex-direction</code>)的时候，才能真正的居中。这时候，我们就特别需要 <code>justify-self</code> 属性。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">  <span class="attribute">background-color</span>: lightyellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">75px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: springgreen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>真正的居中显示<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box1"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box3"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>只有当相邻元素的尺寸相同时，处于中间位置的 DOM 元素才能真正的居中显示。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(点击<a href="http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties" target="_blank" rel="noopener">这里</a>, 前往原答案查看代码的效果)</p>
<p>解决这个问题的办法有两种。</p>
<h3 id="方案一：-绝对定位"><a href="#方案一：-绝对定位" class="headerlink" title="方案一： 绝对定位"></a>方案一： 绝对定位</h3><p><code>flexbox</code> 规定，允许其子元素用绝对定位进行布局。这样的话，相邻元素尺寸不相同的中间元素进行居中布局，也成为了有可能的事情。</p>
<p>别忘了，绝对定位的元素会脱离<a href="https://www.w3.org/TR/CSS22/visuren.html#normal-flow" target="_blank" rel="noopener">文本流</a>。这也就意味着它不再占据其容器元素的空间，并且可以和其他兄弟元素重叠在一起。</p>
<p>在下面的例子中，三个子元素中间的那个元素用绝对定位，居中显示在了容器的正中央，而两个相邻的兄弟元素则仍然保持在文本流中。</p>
<p>其实这个方法也可以反过来用：对三个字元素中间的那个元素使用 <code>justify-content: center</code> 属性，对它的两个兄弟元素用绝对定位。</p>
<p><img src="https://i.stack.imgur.com/U1eLb.png" alt="flexes-9"></p>
<h3 id="方案二：-嵌套使用-flex-容器-不使用绝对定位"><a href="#方案二：-嵌套使用-flex-容器-不使用绝对定位" class="headerlink" title="方案二： 嵌套使用 flex 容器(不使用绝对定位)"></a>方案二： 嵌套使用 <code>flex</code> 容器(不使用绝对定位)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box71</span> &gt; <span class="selector-tag">span</span> &#123; <span class="attribute">margin-right</span>: auto; &#125;</span><br><span class="line"><span class="selector-class">.box73</span> &gt; <span class="selector-tag">span</span> &#123; <span class="attribute">margin-left</span>: auto;  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* non-essential */</span></span><br><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: lightgreen;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box71"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>71 短<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box72"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>72 居中<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box box73"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>73 非常长长长长长长长长长长的元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>(点击<a href="http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties" target="_blank" rel="noopener">这里</a>, 前往原答案查看代码的效果)</p>
<p>这种方法的工作原理：</p>
<ul>
<li>顶层 div(<code>.container</code>) 是一个 <code>flex</code> 容器</li>
<li>每个 div(<code>.box</code>) 元素, 都是一个 <code>flex</code> 元素</li>
<li>为了能均匀的分配容器的空间, 每个 <code>.box</code> 元素都被赋了 <code>flex: 1</code> 属性</li>
<li>现在每行的元素所占据的容器空间都是想等的</li>
<li>把每个 <code>flex</code> 元素都加上属性，变成 <code>flex</code> 容器(译注：就叫二级容器好了), 然后再在其中嵌套 <code>flex</code> 元素，并且给这些新的 <code>flex</code> 容器加上 <code>justify-content: center</code> 属性</li>
<li>现在每个 <code>span</code> 元素是一个居中的 <code>flex</code> 元素了</li>
<li>加上上面讲的<strong>自动外边距</strong>的方法, 让同一行中的外侧的二级容器分别靠左和靠右对齐</li>
</ul>
<p>之所以上面的方法可行，是因为在根据规范, 外边距的布局优先级是高于 <code>justify-content</code> 的：</p>
<blockquote>
<p>8.1. Aligning with auto margins</p>
<p>Prior to alignment via justify-content and align-self, any positive free space is distributed to auto margins in that dimension.</p>
</blockquote>
<p>译文:</p>
<blockquote>
<p>8.1 用自动外边距来排列元素</p>
<p>对应任何剩余的空间分配上, 自动外边距都有高于 <code>justify-content</code> 和 <code>align-self</code> 的分配权。</p>
</blockquote>
<h3 id="justify-content-space-same-概念"><a href="#justify-content-space-same-概念" class="headerlink" title="justify-content: space-same (概念)"></a><strong><em>justify-content: space-same (概念)</em></strong></h3><p>再回到 <a href="http://stackoverflow.com/a/33856609/3597276" target="_blank" rel="noopener"><code>justify-content</code></a> 这个属性上, 其实这个属性已经有了一个新的构想的值:</p>
<ul>
<li><strong>space-same</strong> ~<br>一种 <code>space-between</code> 和 <code>space-around</code> 的混合体。这个属性就像 <code>space-between</code> 一样能让元素均匀分布，只不过这次不是让两头的元素在外边缘之能分配到一半的空间了，而是分配到和两两元素中间一样大小的空间。</li>
</ul>
<p>这种布局效果也能通过在 <code>flex</code> 容器上设置 <code>::after</code> 和 <code>::before</code> 两个伪元素来实现。<br><img src="https://i.stack.imgur.com/Jjw9w.png" alt="flexes-10"></p>
<p>答案作者: <a href="http://stackoverflow.com/users/3597276/michael-b" target="_blank" rel="noopener">Michael_B</a></p>
<p>原文链接: <a href="http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties" target="_blank" rel="noopener">http://stackoverflow.com/questions/32551291/in-css-flexbox-why-are-there-no-justify-items-and-justify-self-properties</a></p>
<p>并没有取得原作者的授权，直接翻译并发布了，本来是想联系作者的，但是找不到邮箱，StackOverflow 荣誉也不够，无法留言。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/02/24/ife-2017-demos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/24/ife-2017-demos/" itemprop="url">
                  百度 IFE 前端学院 2017 demo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-02-24 19:03:21" itemprop="dateCreated datePublished" datetime="2017-02-24T19:03:21+08:00">2017-02-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-11-18 17:12:46" itemprop="dateModified" datetime="2018-11-18T17:12:46+08:00">2018-11-18</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/IFE-Baidu-demo/" itemprop="url" rel="index"><span itemprop="name">IFE Baidu demo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><a href="/demos/ife2017/custome_radio_and_checkbox_style/index.html">自定义 checkbox/radio 样式</a>, 练习<strong>::after/::before/CSS Sprite</strong></li>
<li><a href="/demos/ife2017/custome_right_click_menu/index.html">自定义网页右键菜单</a>, 练习<strong>箭头函数 this 指向/事件代理</strong></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/02/23/how-to-implement-a-accumulator-by-function-currying/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/23/how-to-implement-a-accumulator-by-function-currying/" itemprop="url">
                  用柯里化实现一个累加器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-02-23 09:38:21 / Modified: 11:12:25" itemprop="dateCreated datePublished" datetime="2017-02-23T09:38:21+08:00">2017-02-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/javascript-interview-currying/" itemprop="url" rel="index"><span itemprop="name">javascript interview currying</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>先看一道面试题, 如何实现下面这个函数?<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>);<span class="comment">// 1</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>)(<span class="number">2</span>);<span class="comment">// 3</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">4</span>, <span class="number">10</span>);<span class="comment">// 20</span></span><br></pre></td></tr></table></figure></p>
<p>先是 ES6 版本的答案:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> calculate = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> arr.length === <span class="number">0</span> ? <span class="number">0</span> : arr.length === <span class="number">1</span> ? arr[<span class="number">0</span>] : arr.reduce(<span class="function">(<span class="params">ac, cv</span>) =&gt;</span> ac + cv);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = calculate(args);</span><br><span class="line">  <span class="keyword">const</span> func = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    result += calculate(args);</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.toString = func.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">1</span>)()(<span class="number">3</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></p>
<p>ES5 的版本:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">switch</span>(arr.length) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">ac, cv</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> ac + cv;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = calculate.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    result += calculate.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.toString = func.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">1</span>)()(<span class="number">3</span>); <span class="comment">//10</span></span><br></pre></td></tr></table></figure></p>
<p>这道题和<strong>柯里化</strong>有什么关系呢？</p>
<p>把上面的函数简化一下就可以看出来了:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add_currying = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> result = num;</span><br><span class="line">  <span class="keyword">const</span> func = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">    result += num;</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.toString = func.valueOf = <span class="function"><span class="params">()</span> =&gt;</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_currying(<span class="number">1</span>)(<span class="number">2</span>); <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p>
<h3 id="在-JavaScript-中构造一个柯里化函数的关键"><a href="#在-JavaScript-中构造一个柯里化函数的关键" class="headerlink" title="在 JavaScript 中构造一个柯里化函数的关键"></a>在 JavaScript 中构造一个柯里化函数的关键</h3><p>先看维基百科中, 对柯里化的定义:</p>
<blockquote>
<p>在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。<br>即: </p>
<ol start="0">
<li>需要保持事先传入的参数, 或者第一次传入的参数, 并且返回一个由这个参数构成的新的函数</li>
<li>接下来的计算都通过第 0 步返回的函数执行</li>
</ol>
</blockquote>
<p>在 JavaScript 中即为:</p>
<ol start="0">
<li>利用闭包, 将第一次传入的参数保持住</li>
<li>返回一个与第一次传入的参数一起构成的新函数</li>
</ol>
<p>在实现的技巧上, 用到了 <code>Function.toString()</code> 方法和 <code>Object.valueOf()</code> 方法, 其中 <code>func.toString</code> 是当这个函数需要在 <code>console</code> 面板中显示时调用的方法,<br>而 <code>func.valueOf</code> 是在需要当做值进行传递时调用的方法, 而柯里化本身, 并与此无关, 正因为返回值是函数, 才能称作是柯里化。</p>
<p>可以对 <code>add_currying</code> 或者 <code>add</code> 的值进行 <code>typeof</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> add_currying(<span class="number">1</span>)(<span class="number">2</span>);<span class="comment">// "function"</span></span><br><span class="line"><span class="keyword">typeof</span> add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">1</span>, <span class="number">2</span>);<span class="comment">// "function"</span></span><br></pre></td></tr></table></figure></p>
<p>在实现的过程中, 写了一个错误的答案:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [].slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">switch</span>(arr.length) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">ac, cv</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> ac + cv;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> result = calculate(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    result += calculate(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> func;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func.toString = func.valueOf = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> func;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)(<span class="number">1</span>)()(<span class="number">3</span>); <span class="comment">//6[object Arguments][object Arguments][object Arguments]</span></span><br></pre></td></tr></table></figure></p>
<p>错在哪里了呢？<code>calculate(arguments)</code>的传参上, <code>arguments</code> 是 <strong>array-like</strong>, 而不是 <strong>array</strong>, 直接当做实参传进去的时候, 会被调用 <code>toString()</code> 方法, 形参得到的就是 <code>&#39;[object Arguments]&#39;</code>, 而不是一个 <code>arguments</code> 或者 <code>Array</code> 了。而在 JavaScript 中, 能直接接受 <code>arguments</code> 当做参数的, 只有 <code>apply</code>, 所以正确的传值方式是 <code>calculate.apply(null, arguments)</code>。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://olafcheng.github.io/2017/02/19/ife-front-end-college-2016-demos/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="olaf cheng">
      <meta itemprop="description" content="纸上得来终觉浅，绝知此事要躬行。">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="olaf's site">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/02/19/ife-front-end-college-2016-demos/" itemprop="url">
                  百度 IFE 前端技术学院 2016 练习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              

              
                
              

              <time title="Created: 2017-02-19 21:17:24" itemprop="dateCreated datePublished" datetime="2017-02-19T21:17:24+08:00">2017-02-19</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Modified: 2018-06-16 22:17:26" itemprop="dateModified" datetime="2018-06-16T22:17:26+08:00">2018-06-16</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/ife-demo/" itemprop="url" rel="index"><span itemprop="name">ife demo</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p><a href="/demos/task_1_10/index.html">任务1-10</a>, 练习<strong>flex 布局</strong></p>
</li>
<li><p><a href="/demos/task_1_11/index.html">任务1-11</a>, 练习<strong>响应式开发</strong>, <em>请用移动端打开</em></p>
</li>
<li><p><a href="/demos/task_2_13/index.html">任务2-13</a>, 练习<strong>简单的 DOM 操作</strong></p>
</li>
<li><p><a href="/demos/task_2_14/index.html">任务2-14</a>, 练习<strong>数据排序</strong></p>
</li>
<li><p><a href="/demos/task_2_16/index.html">任务2-16</a>, 练习<strong>DOM 操作、表格</strong></p>
</li>
<li><p><a href="/demos/task_2_17/index.html">任务2-17</a>, 练习<strong>用 DOM 进行数据展示考查数据操作、DOM操作</strong></p>
</li>
<li><p><a href="/demos/task_2_18/index.html">任务2-18</a>, 练习<strong>数据结构中的双向链表、DOM 操作</strong></p>
</li>
<li><p><a href="/demos/task_2_19/index.html">任务2-19</a>, 练习<strong>DOM 生成、排序，用到了插入排序、CSS3 KeyFrame、任务队列</strong></p>
</li>
<li><p><a href="/demos/task_2_20/index.html">任务2-20</a>, 练习<strong>字符串操作，并对查找到的内容进行高亮显示</strong></p>
</li>
<li><p><a href="/demos/task_2_21/index.html">任务2-21</a>, 练习<strong>字符串操作, DOM 操作</strong></p>
</li>
<li><p><a href="/demos/task_2_22/index.html">任务2-22</a>, 练习<strong>二叉树的三种遍历, 并用 DOM 动画显示出来</strong></p>
</li>
<li><p><a href="/demos/task_2_23/index.html">任务2-23</a>, 练习<strong>数据的深度优先遍历、广度优先遍历、以及前序遍历、中序遍历、后序遍历和查找</strong></p>
</li>
<li><p><a href="/demos/task_2_24/index.html">任务2-24</a>, <strong>在任务2-23的基础上, 增加了 <em>update</em> 和 <em>delete</em> 两个按钮, 方便交互</strong></p>
</li>
<li><p><a href="/demos/task_2_26/index.html">任务2-26</a>, 练习<strong>Canvas、mediator 模式、Pub-Sub 模式</strong></p>
</li>
<li><p><a href="/demos/task_2_27/index.html">任务2-27</a>, <strong>在任务2-26的基础上, 对 OOP 中的对象配置进行了抽象, 改善代码的组织方式</strong></p>
</li>
<li><p><a href="/demos/task_2_28/index.html">任务2-28</a>, <strong>在任务2-27点基础上, 用 Adapter 模式, 增加后续的功能</strong></p>
</li>
<li><p><a href="/demos/task_2_29/index.html">任务2-29</a>, <strong>最简单的表单验证</strong></p>
</li>
<li><p><a href="/demos/task_2_30/index.html">任务2-30</a>, 练习<strong>策略模式、正则表达式, 简单的表单验证功能</strong></p>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">olaf cheng</p>
              <p class="site-description motion-element" itemprop="description">纸上得来终觉浅，绝知此事要躬行。</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">10</span>
                    <span class="site-state-item-name">posts</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">8</span>
                    <span class="site-state-item-name">categories</span>
                  
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">olaf cheng</span>

  

  
</div>




  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
